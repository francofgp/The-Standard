"use strict";(self.webpackChunkthe_standard=self.webpackChunkthe_standard||[]).push([[138],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||r;return n?i.createElement(m,s(s({ref:t},d),{},{components:n})):i.createElement(m,s({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},693:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const r={},s="2.2 Processing Services (Higher-Order Business Logic)",o={unversionedId:"Services/2.2 Processings/2.2 Processings",id:"Services/2.2 Processings/2.2 Processings",title:"2.2 Processing Services (Higher-Order Business Logic)",description:"2.2.0 Introduction",source:"@site/docs/2. Services/2.2 Processings/2.2 Processings.md",sourceDirName:"2. Services/2.2 Processings",slug:"/Services/2.2 Processings/",permalink:"/The-Standard/docs/Services/2.2 Processings/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/2. Services/2.2 Processings/2.2 Processings.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2.1 Foundation Services (Broker-Neighboring)",permalink:"/The-Standard/docs/Services/2.1 Foundations/"},next:{title:"2.3 Orchestration Services (Complex Higher Order Logic)",permalink:"/The-Standard/docs/Services/2.3 Orchestrations/"}},l={},c=[{value:"2.2.0 Introduction",id:"220-introduction",level:2},{value:"2.2.1 On The Map",id:"221-on-the-map",level:2},{value:"2.2.2 Charachteristics",id:"222-charachteristics",level:2},{value:"2.2.2.0 Language",id:"2220-language",level:3},{value:"2.2.2.0.0 Functions Language",id:"22200-functions-language",level:4},{value:"2.2.2.0.1 Pass-Through",id:"22201-pass-through",level:4},{value:"2.2.2.0.2 Class-Level Language",id:"22202-class-level-language",level:4},{value:"2.2.2.1 Dependencies",id:"2221-dependencies",level:3},{value:"2.2.2.2 One-Foundation",id:"2222-one-foundation",level:3},{value:"2.2.2.3 Used-Data-Only Validations",id:"2223-used-data-only-validations",level:3},{value:"2.2.3 Responsibilities",id:"223-responsibilities",level:2},{value:"2.2.3.0 Higher-Order Logic",id:"2230-higher-order-logic",level:3},{value:"2.2.3.0.0 Shifters",id:"22300-shifters",level:4},{value:"2.2.3.0.1 Combinations",id:"22301-combinations",level:4},{value:"2.2.3.1 Signature Mapping",id:"2231-signature-mapping",level:3},{value:"2.2.3.1.0 Non-Exception Local Models",id:"22310-non-exception-local-models",level:4},{value:"2.2.3.1.1 Exception Models",id:"22311-exception-models",level:4}],d={toc:c};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"22-processing-services-higher-order-business-logic"},"2.2 Processing Services (Higher-Order Business Logic)"),(0,a.kt)("h2",{id:"220-introduction"},"2.2.0 Introduction"),(0,a.kt)("p",null,"Processing services are the layer where a higher order of business logic is implemented. They may combine (or orchestrate) two primitive-level functions from their corresponding foundation service to introduce a newer functionality. They may also call one primitive function and change the outcome with a little bit of added business logic. And sometimes processing services are there as a pass-through to introduce balance to the overall architecture."),(0,a.kt)("p",null,"Processing services are optional, depending on your business need - in a simple CRUD operations API, processing services and all the other categories of services beyond that point will cease to exist as there is no need for a higher order of business logic at that point."),(0,a.kt)("p",null,"Here's an example of what a Processing service function would look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public ValueTask<Student> UpsertStudentAsync(Student student) =>\nTryCatch(async () =>\n{\n    ValidateStudent(student);\n\n    IQueryable<Student> allStudents =\n        this.studentService.RetrieveAllStudents();\n\n    bool studentExists = allStudents.Any(retrievedStudent =>\n        retrievedStudent.Id == student.Id);\n\n    return studentExists switch {\n        false => await this.studentService.RegisterStudentAsync(student),\n        _ => await this.studentService.ModifyStudentAsync(student.Id)\n    };\n});\n")),(0,a.kt)("p",null,"Processing services make Foundation services nothing but a layer of validation on top of the existing primitive operations. Which means that Processing services functions are beyond primitive, and they only deal with local models as we will discuss in the upcoming sections."),(0,a.kt)("h2",{id:"221-on-the-map"},"2.2.1 On The Map"),(0,a.kt)("p",null,"When used, Processing services live between foundation services and the rest of the application. they may not call Entity or Business brokers, but they may call Utility brokers such as logging brokers, time brokers and any other brokers that offer supporting functionality and not specific to any particular business logic. Here's a visual of where processing services are located on the map of our architecture:"),(0,a.kt)("br",null),(0,a.kt)("p",{align:"center"},(0,a.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/111928442-d9cd1b00-8a70-11eb-82c8-83399c98c87d.png"})),(0,a.kt)("br",null),(0,a.kt)("p",null,"On the right side of a Processing service lies all the non-local models and functionality, whether it's through the brokers, or the models that the foundation service is trying to map into local models.\nOn the left side of Processing services is pure local functionality, models and architecture. Starting from the Processing services themselves, there should be no trace or track of any native or non-local models in the system."),(0,a.kt)("h2",{id:"222-charachteristics"},"2.2.2 Charachteristics"),(0,a.kt)("p",null,"Processing services in general are combiners of multiple primitive-level functions to produce a higher-order business logic. but they have much more characteristics than just that, let's talk about those here."),(0,a.kt)("h3",{id:"2220-language"},"2.2.2.0 Language"),(0,a.kt)("p",null,"The language used in processing services defines the level of complexity and the capabilities it offers.\nUsually, processing services combine two or more primitive operations from the foundation layer to create a new value."),(0,a.kt)("h4",{id:"22200-functions-language"},"2.2.2.0.0 Functions Language"),(0,a.kt)("p",null,"At a glance, Processing services language change from primitive operations such as ",(0,a.kt)("inlineCode",{parentName:"p"},"AddStudent")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoveStudent")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"EnsureStudentExists")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"UpsertStudent"),". they usually offer a more advanced business-logic operations to support a higher order functionality.\nHere's some examples for the most common combinations a processing service may offer:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Processing Operation"),(0,a.kt)("th",{parentName:"tr",align:null},"Primitive Functions"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"EnsureStudentExistsAsync"),(0,a.kt)("td",{parentName:"tr",align:null},"RetrieveAllStudents + AddStudentAsync")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UpsertStudentAsync"),(0,a.kt)("td",{parentName:"tr",align:null},"RetrieveStudentById + AddStudentAsync + ModifyStudentAsync")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"VerifyStudentExists"),(0,a.kt)("td",{parentName:"tr",align:null},"RetrieveAllStudents")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TryRemoveStudentAsync"),(0,a.kt)("td",{parentName:"tr",align:null},"RetrieveStudentById + RemoveStudentByIdAsync")))),(0,a.kt)("p",null,"As you can see, the combination of primitive functions processing services do might also include adding an additional layer of logic on top of the existing primitive operation. For instance, ",(0,a.kt)("inlineCode",{parentName:"p"},"VerifyStudentExists")," takes advantage of the ",(0,a.kt)("inlineCode",{parentName:"p"},"RetrieveAllStudents")," primitive function, and then adds a boolean logic to verify the returned student by and Id from a query actually exists or not before returning a ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),"."),(0,a.kt)("h4",{id:"22201-pass-through"},"2.2.2.0.1 Pass-Through"),(0,a.kt)("p",null,"Processing services may borrow some of the terminology a foundation service may use. for instance, in a pass-through scenario, a processing service with be as simple as ",(0,a.kt)("inlineCode",{parentName:"p"},"AddStudentAsync"),". We will discuss the architecture-balancing scenarios later in this chapter.\nUnlike Foundation services, Processing services are required to have the identifier ",(0,a.kt)("inlineCode",{parentName:"p"},"Processing")," in their names. for instance, we say ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentProcessingService"),"."),(0,a.kt)("h4",{id:"22202-class-level-language"},"2.2.2.0.2 Class-Level Language"),(0,a.kt)("p",null,"More importantly Processing services must include the name of the entity that is supported by their corresponding Foundation service.\nFor instance, if a Processing service is dependant on a ",(0,a.kt)("inlineCode",{parentName:"p"},"TeacherService"),", then the Processing service name must be ",(0,a.kt)("inlineCode",{parentName:"p"},"TeacherProcessingService"),"."),(0,a.kt)("h3",{id:"2221-dependencies"},"2.2.2.1 Dependencies"),(0,a.kt)("p",null,"Processing services can only have two types of dependencies. a corresponding Foundation service, or a Utility broker. That's simply because Processing services are nothing but an extra higher-order level of business logic, orchestrated by combined primitive operations on the Foundation level.\nProcessing services can also use Utility brokers such as ",(0,a.kt)("inlineCode",{parentName:"p"},"TimeBroker")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"LoggingBroker")," to support it's reporting aspect. but it shall never interact with an Entity or Business broker."),(0,a.kt)("h3",{id:"2222-one-foundation"},"2.2.2.2 One-Foundation"),(0,a.kt)("p",null,"Processing services can interact with one and only one Foundation service. In fact without a foundation service there can never be a Processing layer. and just like we mentioned above about the language and naming, Processing services take on the exact same entity name as their Foundation dependency.\nFor instance, a processing service that handles higher-order business-logic for students will communicate with nothing but its foundation layer, which would be ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentService")," for instance. That means that processing services will have one and only one service as a dependency in its construction or initiation as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public class StudentProcessingService\n{\n    private readonly IStudentService studentService;\n\n    public StudentProcessingService(IStudentService studentService) =>\n        this.studentService = studentService;\n}\n")),(0,a.kt)("p",null,"However, processing services may require dependencies on multiple utility brokers such as ",(0,a.kt)("inlineCode",{parentName:"p"},"DateTimeBroker")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"LoggingBroker")," ... etc."),(0,a.kt)("h3",{id:"2223-used-data-only-validations"},"2.2.2.3 Used-Data-Only Validations"),(0,a.kt)("p",null,"Unlike the Foundation layer services, Processing services only validate what it needs from it's input. For instance, if a Processing service is required to validate a student entity exists, and it's input model just happens to be an entire ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," entity, it will only validate that the entity is not ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," and that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Id")," of that entity is valid. the rest of the entity is out of the concern of the Processing service.\nProcessing services delegate full validations to the layer of services that is concerned with that which is the Foundation layer. here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public ValueTask<Student> UpsertStudentAsync(Student student) =>\nTryCatch(async () =>\n{\n    ValidateStudent(student);\n\n    IQueryable<Student> allStudents =\n        this.studentService.RetrieveAllStudents();\n\n    bool isStudentExists = allStudents.Any(retrievedStudent =>\n        retrievedStudent.Id == student.Id);\n\n    return isStudentExsits switch {\n        false => await this.studentService.RegisterStudentAsync(student),\n        _ => await this.studentService.ModifyStudentAsync(student.Id)\n    };\n});\n")),(0,a.kt)("p",null,"Processing services are also not very concerned about outgoing validations except for what it's going to use within the same routine. For instance, if a Processing service is retrieving a model, and it's going to use this model to be passed to another primitive-level function on the Foundation layer, the Processing service will be required to validate that the retrieved model is valid depending on which attributes of the model it uses.\nFor Pass-through scenarios however, processing services will delegate the outgoing validation to the foundation layer."),(0,a.kt)("h2",{id:"223-responsibilities"},"2.2.3 Responsibilities"),(0,a.kt)("p",null,"Processing services main responsibility is to provide higher-order business logic. This happens along with the regular signature mapping and various use-only validations which we will discuss in detail in this section."),(0,a.kt)("h3",{id:"2230-higher-order-logic"},"2.2.3.0 Higher-Order Logic"),(0,a.kt)("p",null,"Higher-order business logic are functions that are above primitive. For instance, ",(0,a.kt)("inlineCode",{parentName:"p"},"AddStudentAsync")," function is a primitive function that does one thing and one thing only. But higher-order logic is when we try to provide a function that changes the outcome of a single primitive function like ",(0,a.kt)("inlineCode",{parentName:"p"},"VerifyStudentExists")," which returns a boolean value instead of the entire object of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Student"),", or a combination of multiple primitive functions such as ",(0,a.kt)("inlineCode",{parentName:"p"},"EnsureStudentExistsAsync")," which is a function that will only add a given ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," model if and only if the aforementioned object doesn't already exist in storage. here's some examples:"),(0,a.kt)("h4",{id:"22300-shifters"},"2.2.3.0.0 Shifters"),(0,a.kt)("p",null,"The shifter pattern in a higher order business logic is when the outcome of a particular primitive function is changed from one value to another. Ideally a primitive type such as a ",(0,a.kt)("inlineCode",{parentName:"p"},"bool")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"int")," not a completely different type as that would violate the purity principle.\nFor instance, in a shifter pattern, we want to verify if a student exists or not. We don't really want the entire object, but just whether it exists in a particular system or not. Now, this seems like a case where we only need to interact with one and only one foundation service and we are shifting the value of the outcome to something else. Which should fit perfectly in the realm of the processing services. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public ValueTask<bool> VerifyStudentExists(Guid studentId) =>\nTryCatch(async () =>\n{\n    IQueryable<Student> allStudents =\n        this.studentService.RetrieveAllStudents();\n\n    ValidateStudents(allStudents);\n\n    return allStudents.Any(student => student.Id == studentId);\n});\n")),(0,a.kt)("p",null,"In the snippet above, we provided a higher order business logic, by returning a boolean value of whether a particular student with a given ",(0,a.kt)("inlineCode",{parentName:"p"},"Id")," exists in the system or not. There are cases where your orchestration layer of services isn't really concerned with all the details of a particular entity but just knowing whether it exists or not as a part of an upper business logic or what we call orchestration."),(0,a.kt)("p",null,"Here's another popular example for processing services shifting pattern:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public int RetrieveStudentsCount() =>\nTryCatch(() =>\n{\n    IQueryable<Student> allStudents =\n        this.studentService.RetrieveAllStudents();\n\n    ValidateStudents(allStudents);\n\n    return allStudents.Count();\n});\n")),(0,a.kt)("p",null,"In the example above, we provided a function to retrieve the count of all students in a given system. It's up to the designers of the system to determine whether to interpret a ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," value retrieved for all students to be an exception case that was not expected to happen or return a ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),"; all depending on how they manage the outcome.\nIn our case here we validate the outgoing data as much as the incoming, especially if it's going to be used within the processing function to ensure further failures do not occur for upstream services."),(0,a.kt)("h4",{id:"22301-combinations"},"2.2.3.0.1 Combinations"),(0,a.kt)("p",null,"The combination of multiple primitive functions from the foundation layer to achieve a higher-order business logic is one of the main responsibilities of a processing service. As we mentioned before, some of the most popular examples is for ensuring a particular student model exists as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> EnsureStudentExistsAsync(Student student) =>\nTryCatch(async () =>\n{\n    ValidateStudent(student);\n\n    IQueryable<Student> allStudents =\n        this.studentService.RetrieveAllStudents();\n\n    Student maybeStudent = allStudents.FirstOrDefault(retrievedStudent =>\n        retrievedStudent.Id == student.Id);\n\n    return maybeStudent switch\n    {\n        {} => maybeStudent,\n        _ => await this.studentService.AddStudentAsync(student)\n    };\n});\n")),(0,a.kt)("p",null,"In the code snippet above, we combined ",(0,a.kt)("inlineCode",{parentName:"p"},"RetrieveAll")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"AddAsync")," to achieve a higher-order business logic operation. The ",(0,a.kt)("inlineCode",{parentName:"p"},"EnsureAsync")," operation which needs to verify something or entity exists first before trying to persist it. The terminology around these higher-order business logic routines is very important. Its importance lies mainly in controlling the expectations of the outcome and the inner functionality. But it also ensures less cognitive resources from the engineers are required to understand the underlying capabilities of a particular routine.\nThe conventional language used in all of these services also ensures that redundant capability will not be created mistakenly. For instance, an engineering team without any form of standard might create ",(0,a.kt)("inlineCode",{parentName:"p"},"TryAddStudentAsync")," while already having an existing functionality such as ",(0,a.kt)("inlineCode",{parentName:"p"},"EnsureStudentExistsAsync")," which does exactly the same thing. The convention here with the limitation of the size of capabilities a particular service may have ensures redundant work shall never occur in any occassion.\nThere are so many different instances of combinations that can produce a higher-order business logic, for instance we may need to implement a functionality that ensure a student is removed. We use ",(0,a.kt)("inlineCode",{parentName:"p"},"EnsureStudentRemovedByIdAsync")," to combine a ",(0,a.kt)("inlineCode",{parentName:"p"},"RetrieveById")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoveById")," in the same routine. It all depends on what level of capabilities an upstream service may need to implement such a functionality."),(0,a.kt)("h3",{id:"2231-signature-mapping"},"2.2.3.1 Signature Mapping"),(0,a.kt)("p",null,"Although processing services operate fully on local models and local contracts, they are still required to map foundation-level services' models to their own local models. For instance, if a foundation service is throwing ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentValidationException")," then processing services will map that exception to ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentProcessingDependencyValidationException"),". Let's talk about mapping in this section."),(0,a.kt)("h4",{id:"22310-non-exception-local-models"},"2.2.3.1.0 Non-Exception Local Models"),(0,a.kt)("p",null,"In general, processing services are required to map any incoming or outgoing objects with a specific model to its own. But that rule doesn't always apply to non-exception models. For instance, if a ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentProcessingService")," is operating based on a ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," model, and there's no need for a special model for this service, then the processing service may be permitted to use the exact same model from the foundation layer."),(0,a.kt)("h4",{id:"22311-exception-models"},"2.2.3.1.1 Exception Models"),(0,a.kt)("p",null,"When it comes to processing services handling exceptions from the foundation layer, it is important to understand that exceptions in our Standard are more expressive in their naming conventions and their role more than any other model. Exceptions here define the what, where and why every single time they are thrown.\nFor instance, an exception that's called ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentProcessingServiceException")," indicates the entity of the exception which is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," entity. Then it indicates the location of the exception which is the ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentProcessingService"),". And lastly it indicates the reason for that exception which is ",(0,a.kt)("inlineCode",{parentName:"p"},"ServiceException")," indicating an internal error to the service that is not a validation or a dependency of nature that happened.\nJust like the foundation layer, processing services will do the following mapping to occurring exceptions from its dependencies:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Exception"),(0,a.kt)("th",{parentName:"tr",align:null},"Wrap Inner Exception With"),(0,a.kt)("th",{parentName:"tr",align:null},"Wrap With"),(0,a.kt)("th",{parentName:"tr",align:null},"Log Level"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"StudentDependencyValidationException"),(0,a.kt)("td",{parentName:"tr",align:null},"Any inner exception"),(0,a.kt)("td",{parentName:"tr",align:null},"StudentProcessingDependencyValidationException"),(0,a.kt)("td",{parentName:"tr",align:null},"Error")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"StudentValidationException"),(0,a.kt)("td",{parentName:"tr",align:null},"Any inner exception"),(0,a.kt)("td",{parentName:"tr",align:null},"StudentProcessingDependencyValidationException"),(0,a.kt)("td",{parentName:"tr",align:null},"Error")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"StudentDependencyException"),(0,a.kt)("td",{parentName:"tr",align:null},"-"),(0,a.kt)("td",{parentName:"tr",align:null},"StudentProcessingDependencyException"),(0,a.kt)("td",{parentName:"tr",align:null},"Error")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"StudentServiceException"),(0,a.kt)("td",{parentName:"tr",align:null},"_"),(0,a.kt)("td",{parentName:"tr",align:null},"StudentProcessingDependencyException"),(0,a.kt)("td",{parentName:"tr",align:null},"Error")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Exception"),(0,a.kt)("td",{parentName:"tr",align:null},"_"),(0,a.kt)("td",{parentName:"tr",align:null},"StudentProcessingServiceException"),(0,a.kt)("td",{parentName:"tr",align:null},"Error")))),(0,a.kt)("p",null,"[*][Processing services in Action (Part 1)]","(",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=VgzoZ-b1A4U"},"https://www.youtube.com/watch?v=VgzoZ-b1A4U"),")"),(0,a.kt)("p",null,"[*][Processing services in Action (Part 2)]","(",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=4lfZcWzbIcE"},"https://www.youtube.com/watch?v=4lfZcWzbIcE"),")"),(0,a.kt)("p",null,"[*][Processing services in Action (Part 3)]","(",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=R4sA4V4-_5o"},"https://www.youtube.com/watch?v=R4sA4V4-_5o"),")"),(0,a.kt)("p",null,"[*][Processing services in Action (Part 4)]","(",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=u4uqBiB1TaI"},"https://www.youtube.com/watch?v=u4uqBiB1TaI"),")"))}u.isMDXComponent=!0}}]);