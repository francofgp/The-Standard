"use strict";(self.webpackChunkthe_standard=self.webpackChunkthe_standard||[]).push([[5285],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},g=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),g=l(n),p=r,h=g["".concat(c,".").concat(p)]||g[p]||u[p]||a;return n?i.createElement(h,o(o({ref:t},d),{},{components:n})):i.createElement(h,o({ref:t},d))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=g;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}g.displayName="MDXCreateElement"},9626:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=n(7462),r=(n(7294),n(3905));const a={},o="2.4 Aggregation Services (The Knot)",s={unversionedId:"Services/2.4 Aggregations/2.4 Aggregations",id:"Services/2.4 Aggregations/2.4 Aggregations",title:"2.4 Aggregation Services (The Knot)",description:"2.4.0 Introduction",source:"@site/docs/2. Services/2.4 Aggregations/2.4 Aggregations.md",sourceDirName:"2. Services/2.4 Aggregations",slug:"/Services/2.4 Aggregations/",permalink:"/The-Standard/docs/Services/2.4 Aggregations/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/2. Services/2.4 Aggregations/2.4 Aggregations.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2.3 Orchestration Services (Complex Higher Order Logic)",permalink:"/The-Standard/docs/Services/2.3 Orchestrations/"},next:{title:"3 Exposers",permalink:"/The-Standard/docs/Exposers/"}},c={},l=[{value:"2.4.0 Introduction",id:"240-introduction",level:2},{value:"2.4.1 On The Map",id:"241-on-the-map",level:2},{value:"2.4.2 Characteristics",id:"242-characteristics",level:2},{value:"2.4.2.0 No Dependency Limitation",id:"2420-no-dependency-limitation",level:3},{value:"2.4.2.1 No Order Validation",id:"2421-no-order-validation",level:3},{value:"2.4.2.2 Basic Validations",id:"2422-basic-validations",level:3},{value:"2.4.2.3 Pass-Through",id:"2423-pass-through",level:3},{value:"2.4.2.4 Optionality",id:"2424-optionality",level:3},{value:"2.4.2.5 Routine-Level Aggregation",id:"2425-routine-level-aggregation",level:3},{value:"2.4.2.6 Pure Dependency Contracts",id:"2426-pure-dependency-contracts",level:3},{value:"2.4.3 Responsibilities",id:"243-responsibilities",level:2},{value:"2.4.3.0 Abstraction",id:"2430-abstraction",level:3},{value:"2.4.3.1 Exceptions Aggregation",id:"2431-exceptions-aggregation",level:3}],d={toc:l};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"24-aggregation-services-the-knot"},"2.4 Aggregation Services (The Knot)"),(0,r.kt)("h2",{id:"240-introduction"},"2.4.0 Introduction"),(0,r.kt)("p",null,"Aggregation services main responsibility is to expose one single point of contact between the core business logic layer and any exposure layers. It ensures, if multiple services of any variation share the same contract, that they are aggregated and exposed to one exposer component through one logical layer."),(0,r.kt)("p",null,"Aggregation services don't hold any business logic in themselves. They are simply a knot that ties together multiple services of any number. They can have any layer of services as dependencies and it mainly exposes the call to these services accordingly. Here's a code example of an aggregation service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask ProcessStudentAsync(Student student)\n{\n    await this.studentRegistrationCoordinationService.RegisterStudentAsync(student);\n    await this.studentRecordsCoordinationService.AddStudentRecordAsync(student);\n    ...\n    ...\n    await this.anyOtherStudentRelatedCoordinationService.DoSomethingWithStudentAsync(student);    \n}\n")),(0,r.kt)("p",null,"As the snippet shows above, an Aggregation service may have any number of calls in any order without limitation. And there may be occasions where you may or may not need to return a value to your exposure layers depending on the overall flow and architecture, which we will discuss shortly in this chapter. But more importantly Aggregation services should not be mistaken for an orchestration service or any of its variants."),(0,r.kt)("h2",{id:"241-on-the-map"},"2.4.1 On The Map"),(0,r.kt)("p",null,"Aggregation services always sit on the other end of a core business logic layer. They are the last point of contact between exposure layers and logic layers. here's a visualization of where aggregation services would be located in an overall architecture:"),(0,r.kt)("br",null),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/147583126-c2b73db9-f77f-486f-806a-e9bfe32cec16.png"})),(0,r.kt)("br",null),(0,r.kt)("p",null,"Let's discuss the characteristics of Aggregation services."),(0,r.kt)("h2",{id:"242-characteristics"},"2.4.2 Characteristics"),(0,r.kt)("p",null,"Aggregation services mainly exist when there are multiple services, sharing the same contract or sharing primitive types of the same contract, that require a single point of exposure. They mainly exist in hyper-complex applications where multiple services (usually orchestration or higher but can be lower) require one single point of contact through exposure layers. Let's talk in detail about the main characteristics for Aggregation services."),(0,r.kt)("h3",{id:"2420-no-dependency-limitation"},"2.4.2.0 No Dependency Limitation"),(0,r.kt)("p",null,"Unlike any other service, Aggregation services can have any number of dependencies as long as these services are of the same variation. For instance, an Aggregation service cannot aggregate between an Orchestration service and a Coordination service. It's a partial Florance-Like pattern where services have to be of the same variation but not necessary limited by the number."),(0,r.kt)("p",null,"The reason for the lack of limitation of the dependencies for Aggregation services is because the service itself doesn't perform any level of business logic between these services. It doesn't care what these services do or require. It only focuses on exposing these services regardless of what was called before or after them."),(0,r.kt)("p",null,"Here's what an Aggregation service test would look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"\n[Fact]\npublic async Task ShouldProcessStudentAsync()\n{\n    // given\n    Student randomStudent = CreatedRandomStudent();\n    Student inputStudent = randomStudent;\n\n    // when\n    await this.studentAggregationService.ProcessStudentAsync(inputStudent);\n\n    // then\n    this.studentRegistrationCoordinationServiceMock.Verify(service =>\n        service.RegisterStudentAsync(student),\n            Times.Once);\n\n    this.studentRecordsCoordinationServiceMock.Verify(service =>\n        service.AddStudentRecordAsync(student),\n            Times.Once);\n    ...\n    ...\n\n    this.anyOtherStudentRelatedCoordinationServiceMock.Verify(service =>\n        service.DoSomethingWithStudentAsync(student),\n            Times.Once);\n\n    this.studentRegistrationCoordinationServiceMock.VerifyNoOtherCalls();\n    this.studentRecordsCoordinationServiceMock.VerifyNoOtherCalls();\n    ...\n    ...\n    this.anyOtherStudentRelatedCoordinationServiceMock.VerifyNoOtherCalls();\n}\n")),(0,r.kt)("p",null,"As you can see above, we are only verifying and testing for the aggregation aspect of calling these services. No return type required in this scenario but there might be in the scenarios of pass-through which we will be discussing shortly."),(0,r.kt)("p",null,"An implementation of the above test would be as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask ProcessStudentAsync(Student student)\n{\n    await this.studentRegistrationCoordinationService.RegisterStudentAsync(student);\n    await this.studentRecordsCoordinationService.AddStudentRecordAsync(student);\n    ...\n    ...\n    await this.anyOtherStudentRelatedCoordinationService.DoSomethingWithStudentAsync(student);    \n}\n")),(0,r.kt)("h3",{id:"2421-no-order-validation"},"2.4.2.1 No Order Validation"),(0,r.kt)("p",null,"By definition, Aggregation services are naturally required to call several dependencies with no limitation. The order of calling these dependencies is also not a concern or a responsibility for Aggregation services. That's simply because the call-order verification is considered a core business logic. which falls outside of the responsibilities of an Aggregation service. That of course includes both natural order of verification or enforced order of verification as we explained in section 2.3.3.0.1 in the previous chapter."),(0,r.kt)("p",null,"It's a violation of The Standard to attempt using simple techniques like a mock sequence in testing an Aggregation service. These responsibilities are more likely to fall on the next lower layer of an Aggregation service for any orchestration-like service. It is also a violation to verify reliance on the return value of one service call to initiate a call to the next."),(0,r.kt)("h3",{id:"2422-basic-validations"},"2.4.2.2 Basic Validations"),(0,r.kt)("p",null,"Aggregation services are still required to validate whether the incoming data is higher-level structurally valid or not. For instance, an Aggregation service that takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"Student")," object as an input parameter will validate only if the ",(0,r.kt)("inlineCode",{parentName:"p"},"student")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or not. But that's where it all stops."),(0,r.kt)("p",null,"There may be an occasion where a dependency requires a property of an input parameter to be passed in, in which case it is also permitted to validate that property value structurally. For instance, if a downstream dependency requires a student name to be passed in. An Aggregation service is still going to be required to validate if the ",(0,r.kt)("inlineCode",{parentName:"p"},"Name")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", empty or just whitespace."),(0,r.kt)("h3",{id:"2423-pass-through"},"2.4.2.3 Pass-Through"),(0,r.kt)("p",null,"Aggregation services are not also required to implement their aggregation by performing multiple calls from one method. They can also aggregate by offering a pass-through methods for multiple services. For instance, assume we have ",(0,r.kt)("inlineCode",{parentName:"p"},"studentCoordinationService")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"studentRecordsService")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"anyOtherStudentRelatedCoordinationService")," and each one of these services are independent in terms of business flow. So an aggregation here is only at the level of exposure but not necessarily the level of execution."),(0,r.kt)("p",null,"Here's a code example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public partial class StudentAggregationService\n{\n    ...\n\n    public async ValueTask<Student> RegisterStudentAsync(Student student)\n    {\n        ...\n\n        return await this.studentCoordinationService.RegisterStudentAsync(student);\n    }\n\n    public async ValueTask<Student> AddStudentRecordAsync(Student student)\n    {\n        ...\n\n        return await this.studentRecordsCoordinationService.AddStudentRecordAsync(student);\n    }\n\n    ...\n    ...\n\n    public async ValueTask<Student> DoSomethingWithStudentAsync(Student student)\n    {\n        ...\n\n        return await this.anyOtherStudentRelatedCoordinationService.DoSomethingWithStudentAsync(student);\n    }\n}\n")),(0,r.kt)("p",null,"As you can see above, each service is using the Aggregation service as a pass-through. There's no need in this scenario whatsoever for an aggregated routines call. This would still be a very valid scenario for Aggregation services."),(0,r.kt)("h3",{id:"2424-optionality"},"2.4.2.4 Optionality"),(0,r.kt)("p",null,"It is important to mention here that Aggregation services are optional. Unlike foundation services, Aggregation services may or may not exist in any architecture. Aggregation services are there to solve a problem with abstraction. This problem may or may not exist based on whether the architecture requires a single point of exposure at the border of the core business logic layer or not. This single responsibility of Aggregation services makes it much simpler to implement its task and perform its function easily. Aggregation services being optional is more likely to be than any other lower-level services. Even in the most complex of applications out there."),(0,r.kt)("h3",{id:"2425-routine-level-aggregation"},"2.4.2.5 Routine-Level Aggregation"),(0,r.kt)("p",null,"If an aggregation service has to make two different calls from the same dependency amongst other calls, It is recommended to aggregate for every dependency routine. But that's only from code-cleanliness perspective and it doesn't necessarily impact the architecture or the end-result in any way."),(0,r.kt)("p",null,"here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask ProcessStudent(Student student)\n{\n    await this.studentCoordinationService.AddStudentAsync(student);\n    await ProcessStudentRecordAsync(student);\n}\n\nprivate async ValueTask ProcessStudentRecordAsync(Student student)\n{\n    await this.studentRecordCoordinationService.AddStudentRecordAsync(student);\n    await this.studentRecordCoordinationService.NotifyStudentRecordAdminsAsync(student);\n}\n\n")),(0,r.kt)("p",null,"This organizational action doesn't warrant any kind of change in terms of testing or end-result as previously mentioned."),(0,r.kt)("h3",{id:"2426-pure-dependency-contracts"},"2.4.2.6 Pure Dependency Contracts"),(0,r.kt)("p",null,"The most important rule/characteristic of an Aggregation service is that its dependencies (unlike orchestration services) must share the same contract. The input parameter for a public routine in any Aggregation service must be the same for all its dependencies. There may be occasions where a dependency may require a student id instead of of the entire student that is permitted with caution as long as the partial contract isn't a return type of another call within the same routine."),(0,r.kt)("h2",{id:"243-responsibilities"},"2.4.3 Responsibilities"),(0,r.kt)("p",null,"Aggregation services main responsibility is to offer a single point of contact between exposer components and the rest of the core business logic. But in essence, abstraction is the true value Aggregation services offer to ensure any business component as a whole is pluggable into any system regardless of the style of exposure this very system may need."),(0,r.kt)("p",null,"Let's talk about these responsibilities in detail."),(0,r.kt)("h3",{id:"2430-abstraction"},"2.4.3.0 Abstraction"),(0,r.kt)("p",null,"An aggregation service performs into responsibility successfully when its clients or consumers have no idea what lies beyond the lines of its implementation. An Aggregation service could be combining 10 different services and exposes a single routine in a fire-n-forget scenario."),(0,r.kt)("p",null,"But even in pass-through scenarios, Aggregation services abstract away any identification of the underlying dependency from exposers at all costs. It doesn't always happen especially in terms of localized exceptions but close enough to make the integration seem as if it is with one single service that's offering all the options natively."),(0,r.kt)("h3",{id:"2431-exceptions-aggregation"},"2.4.3.1 Exceptions Aggregation"),(0,r.kt)("p",null,"Aggregation services are also similar to orchestration-like services in terms of mapping and aggregating exceptions from downstream dependencies. For instance, if ",(0,r.kt)("inlineCode",{parentName:"p"},"studentCoordinationService")," is throwing ",(0,r.kt)("inlineCode",{parentName:"p"},"StudentCoordinationValidationException"),"an Aggregation service would map that into ",(0,r.kt)("inlineCode",{parentName:"p"},"StudentAggregationDependencyValidationException"),". This falls back into the concept of exception unwrapping then wrapping of localized exceptions which we spoke about in detail in section 2.3.3.0.2 of this Standard."))}u.isMDXComponent=!0}}]);