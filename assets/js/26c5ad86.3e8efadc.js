"use strict";(self.webpackChunkthe_standard=self.webpackChunkthe_standard||[]).push([[9703],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=d(n),m=r,h=c["".concat(s,".").concat(m)]||c[m]||p[m]||l;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var d=2;d<l;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1383:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const l={},o="3.1.1 RESTful APIs",i={unversionedId:"Exposers/3.1 Communication Protocols/3.1.1 RESTful APIs/3.1.1 RESTful APIs",id:"Exposers/3.1 Communication Protocols/3.1.1 RESTful APIs/3.1.1 RESTful APIs",title:"3.1.1 RESTful APIs",description:"3.1.1.0 Introduction",source:"@site/docs/3. Exposers/3.1 Communication Protocols/3.1.1 RESTful APIs/3.1.1 RESTful APIs.md",sourceDirName:"3. Exposers/3.1 Communication Protocols/3.1.1 RESTful APIs",slug:"/Exposers/3.1 Communication Protocols/3.1.1 RESTful APIs/",permalink:"/The-Standard/docs/Exposers/3.1 Communication Protocols/3.1.1 RESTful APIs/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/3. Exposers/3.1 Communication Protocols/3.1.1 RESTful APIs/3.1.1 RESTful APIs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"3.1 Communication Protocols",permalink:"/The-Standard/docs/Exposers/3.1 Communication Protocols/"},next:{title:"3.2 User Interfaces",permalink:"/The-Standard/docs/Exposers/3.2 User Interfaces/"}},s={},d=[{value:"3.1.1.0 Introduction",id:"3110-introduction",level:2},{value:"3.1.1.1 On the Map",id:"3111-on-the-map",level:2},{value:"3.1.1.2 Characteristics",id:"3112-characteristics",level:2},{value:"3.1.1.2.0 Language",id:"31120-language",level:3},{value:"3.1.1.2.0.0 Beyond CRUD Routines",id:"311200-beyond-crud-routines",level:4},{value:"3.1.1.2.0.1 Similar Verbs",id:"311201-similar-verbs",level:4},{value:"3.1.1.2.0.2 Routes Conventions",id:"311202-routes-conventions",level:4},{value:"3.1.1.2.0.2.0 Controller Routes",id:"3112020-controller-routes",level:5},{value:"3.1.1.2.0.2.1 Routine Routes",id:"3112021-routine-routes",level:5},{value:"3.1.1.2.0.2.2 Plural Singular Plural",id:"3112022-plural-singular-plural",level:5},{value:"3.1.1.2.0.2.2 Query Parameters &amp; OData",id:"3112022-query-parameters--odata",level:5},{value:"3.1.1.2.1 Codes &amp; Responses",id:"31121-codes--responses",level:3},{value:"3.1.1.2.1.0 Success Codes (2xx)",id:"311210-success-codes-2xx",level:4},{value:"3.1.1.2.1.1 User Error Codes (4xx)",id:"311211-user-error-codes-4xx",level:4},{value:"3.1.1.2.1.2 System Error Codes (5xx)",id:"311212-system-error-codes-5xx",level:4},{value:"3.1.1.2.1.3 All Codes",id:"311213-all-codes",level:4},{value:"3.1.1.2.2 Single Dependency",id:"31122-single-dependency",level:3},{value:"3.1.1.2.3 Single Contract",id:"31123-single-contract",level:3},{value:"3.1.1.3 Organization",id:"3113-organization",level:2},{value:"3.1.1.4 Home Controller",id:"3114-home-controller",level:2},{value:"3.1.1.5 Tests",id:"3115-tests",level:2}],u={toc:d};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"311-restful-apis"},"3.1.1 RESTful APIs"),(0,r.kt)("h2",{id:"3110-introduction"},"3.1.1.0 Introduction"),(0,r.kt)("p",null,"RESTful API controllers are a liaison between the core business logic layer and the outside world. They sit on the other side of the core business realm of any application. In a way, API Controllers are just like Brokers. They ensure a successful integration between our core logic and the rest of the world."),(0,r.kt)("h2",{id:"3111-on-the-map"},"3.1.1.1 On the Map"),(0,r.kt)("p",null,"Controllers sit at the edge of any system. Regardless whether this system is a monolithic platform or simple microservice. API controllers today even apply to smaller lambdas or cloud functions. They play the role of a trigger to access these resources in any system through REST."),(0,r.kt)("br",null),(0,r.kt)("div",null,(0,r.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/147741682-63434be5-3122-4484-b9a1-fd013f18b1b0.png"})),(0,r.kt)("br",null),(0,r.kt)("p",null,"The consumer side of controllers can vary. In production systems these consumers can be other services requiring data from a particular API endpoint. They can be libraries built as wrappers around the controller APIs to provide a local resource with external data. But consumers can also be just engineers testing endpoints, validating their behaviors through swagger documents."),(0,r.kt)("h2",{id:"3112-characteristics"},"3.1.1.2 Characteristics"),(0,r.kt)("p",null,"There are several rules and principles that govern the implementation of RESTful API endpoints. Let's discuss those here."),(0,r.kt)("h3",{id:"31120-language"},"3.1.1.2.0 Language"),(0,r.kt)("p",null,"Controllers speak a different language when it comes to implementing their methods as compared to services and brokers. For instance, if a broker that interfaces with a storage uses a language such as ",(0,r.kt)("inlineCode",{parentName:"p"},"InsertStudentAsync"),", and its corresponding service implementation uses something like ",(0,r.kt)("inlineCode",{parentName:"p"},"AddStudentAsync")," the controller equivalent will be using RESTful language such as ",(0,r.kt)("inlineCode",{parentName:"p"},"PostStudentAsync"),"."),(0,r.kt)("p",null,"There are only a handful of terminologies a controller would use to express a certain operation. Let's draw the map here for clarity:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Controllers"),(0,r.kt)("th",{parentName:"tr",align:null},"Services"),(0,r.kt)("th",{parentName:"tr",align:null},"Brokers"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Post"),(0,r.kt)("td",{parentName:"tr",align:null},"Add"),(0,r.kt)("td",{parentName:"tr",align:null},"Insert")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Get"),(0,r.kt)("td",{parentName:"tr",align:null},"Retrieve"),(0,r.kt)("td",{parentName:"tr",align:null},"Select")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Put"),(0,r.kt)("td",{parentName:"tr",align:null},"Modify"),(0,r.kt)("td",{parentName:"tr",align:null},"Update")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Delete"),(0,r.kt)("td",{parentName:"tr",align:null},"Remove"),(0,r.kt)("td",{parentName:"tr",align:null},"Delete")))),(0,r.kt)("p",null,"The language controllers speak is called Http Verbs. Their range are wider than the aforementioned CRUD operations. For instance, there is PATCH which allows API consumers to update only portions of a particular document. PATCH is rarely used today from my experience in productionized applications. But I may specialize a special section for them at some point in time in future versions of The Standard."),(0,r.kt)("h4",{id:"311200-beyond-crud-routines"},"3.1.1.2.0.0 Beyond CRUD Routines"),(0,r.kt)("p",null,"But as we mentioned before, controller can interface with more than just a foundation service. They can interface with higher-order business logic function. For instance, a processing service may offer an ",(0,r.kt)("inlineCode",{parentName:"p"},"Upsert")," routine. In which case a typical Http Verb wouldn't be able to satisfy a combinational routine such as an ",(0,r.kt)("inlineCode",{parentName:"p"},"Upsert"),". In which case we resolve to the intial state of ",(0,r.kt)("inlineCode",{parentName:"p"},"Post")," assuming the resource doesn't exist."),(0,r.kt)("p",null,"It may become useful to notify our consumers if we decided to modify instead of add which operation we decided to go with. But that's a case by case implementation and more often than ever, consumers don't really care to learn that piece of information. The same idea applies to other languages non-foundation services may use. Such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Process")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Calculate")," or any other business-specific language higher or hyper advanced order services may choose."),(0,r.kt)("h4",{id:"311201-similar-verbs"},"3.1.1.2.0.1 Similar Verbs"),(0,r.kt)("p",null,"Sometimes, especially with basic CRUD operations, you will need the same Http Verb to describe two different routines. For instnace, integrating with both ",(0,r.kt)("inlineCode",{parentName:"p"},"RetrieveById")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RetrieveAll")," both resolve to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Get")," operation on the RESTful realm. In which case each function will have a different name, while maintainig the same verb as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet]\npublic ActionResult<IQueryable<Student>> GetAllStudents()\n{\n    ...\n}\n\n[HttpGet("{studentId}")]\npublic async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)\n{\n    ...\n}\n')),(0,r.kt)("p",null,"As you can see above, the differentiator here is both the function name ",(0,r.kt)("inlineCode",{parentName:"p"},"GetAllStudents")," versus ",(0,r.kt)("inlineCode",{parentName:"p"},"GetStudentByIdAsync")," but also the ",(0,r.kt)("inlineCode",{parentName:"p"},"Route")," at the same time. We will discuss routes shortly, but the main aspect here is the ability to implement multiple routines with different names even if they resolve to the same Http Verb."),(0,r.kt)("h4",{id:"311202-routes-conventions"},"3.1.1.2.0.2 Routes Conventions"),(0,r.kt)("p",null,"RESTful API controllers are accessible through routes. a route is simply a url that is used combined with an Http Verb so the system knows which routine it needs to call to match that route. For instance, if I need to retrieve a student with Id ",(0,r.kt)("inlineCode",{parentName:"p"},"123")," then my api route would be as follows: ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students/123"),". And if I want to retrieve all the students in some system, I could just call ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"GET")," verb."),(0,r.kt)("h5",{id:"3112020-controller-routes"},"3.1.1.2.0.2.0 Controller Routes"),(0,r.kt)("p",null,"The controller class in a simple ASP.NET application can be simply setup at the top of the controller class declaration with a decoration as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[ApiController]\n[Route("api/[controller]")]\npublic class StudentsController\n{\n    ...\n}\n')),(0,r.kt)("p",null,"The route there is a template that defines the endpoint to start with ",(0,r.kt)("inlineCode",{parentName:"p"},"api"),' and trailed by omitting the term "Controller" from the class name. So ',(0,r.kt)("inlineCode",{parentName:"p"},"StudentsController")," would endup being ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students"),". It's important that all controllers should have a plural version of the contract they are serving. Unlike services where we say ",(0,r.kt)("inlineCode",{parentName:"p"},"StudentService")," controllers would be the plural version with ",(0,r.kt)("inlineCode",{parentName:"p"},"StudentsController"),"."),(0,r.kt)("h5",{id:"3112021-routine-routes"},"3.1.1.2.0.2.1 Routine Routes"),(0,r.kt)("p",null,"The same idea applies to methods within the controller class. As we say in the code snippet above, we decorated ",(0,r.kt)("inlineCode",{parentName:"p"},"GetStudentByIdAsync")," have had an ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpGet")," decoration with a particular route identified to append to the existing controller overall route. For instance if the controller route is ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students"),", a routine with ",(0,r.kt)("inlineCode",{parentName:"p"},'HttpGet("{studentId})')," would result in a route that looks like this: ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students/{studentId}"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"studentId")," then would be mapped in as an input parameter variable that ",(0,r.kt)("em",{parentName:"p"},"must")," match the variable defined in the route as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet("{studentId}")]\npublic async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)\n{\n    ...\n}\n')),(0,r.kt)("p",null,"But sometimes these routes are not just url parameters. Sometimes they contain a request within them. For instance, let's say we want to post a library card against a particular student record. Our endpoint would look something like this: ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students/{studentId}/librarycards")," with a ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," verb. In this case we have to distinguish between these two input parameters with proper naming as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpPost("{studentId}/librarycards")]\npublic async ValueTask<ActionResult<LibraryCard>> PostLibraryCardAsync(Guid studentId, LibraryCard libraryCard)\n{\n    ...\n}\n')),(0,r.kt)("h5",{id:"3112022-plural-singular-plural"},"3.1.1.2.0.2.2 Plural Singular Plural"),(0,r.kt)("p",null,"When defining routes in a RESTful API, it is important to follow the global naming conventions for these routes. The general rule is to access a collection of resources, then target a particular entity, then again acess a collection of resources within that entity and so on and so forth. For instance, in the library card example above ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students/{studentId}/librarycards/{librarycardId}")," you can see we started by accessing all students, then targetted a student with a particular id, then we wanted to access all library cards attached to that student then target a very particular card by referencing its id."),(0,r.kt)("p",null,"That convention works perfectly in one-to-many relationships. But what about one-to-one relationships? Let's assume a student may have one and only one library card at all times. In which case our route would still look something like this: ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students/{studentId}/librarycards")," with a ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," verb, and an error would occur as ",(0,r.kt)("inlineCode",{parentName:"p"},"CONFLICT")," if a card is already in place regardless whether the Ids match or not."),(0,r.kt)("h5",{id:"3112022-query-parameters--odata"},"3.1.1.2.0.2.2 Query Parameters & OData"),(0,r.kt)("p",null,"But the route I recommend is the flat-model route. Where every resource lives on it's own with it's own unique routes. In our case here pulling a library card for a particular student would be as follows: ",(0,r.kt)("inlineCode",{parentName:"p"},"api/librarycards?studentId={studentId}")," or simply use a slightly advanced global technology such as OData where the query would just be ",(0,r.kt)("inlineCode",{parentName:"p"},"api/librarycards?$filter=studentId eq '123'"),"."),(0,r.kt)("p",null,"Here's an example of implementing basic query parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[HttpPost()]\npublic async ValueTask<ActionResult<LibraryCard>> PostLibraryCardAsync(Guid studentId, LibraryCard libraryCard)\n{\n    ...\n}\n")),(0,r.kt)("p",null,"On the OData side, an implementation would be as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[HttGet]\n[EnableQuery]\npublic async ValueTask<IQueryable<LibraryCard>> GetAllLibraryCards()\n{\n    ...\n}\n")),(0,r.kt)("p",null,"The same idea applies to ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," for a model. instead of posting towards: ",(0,r.kt)("inlineCode",{parentName:"p"},"api/students/{studentId}/librarycards")," - we can leverage the contract itself to post against ",(0,r.kt)("inlineCode",{parentName:"p"},"api/librarycards")," with a model that contains the student id within. This flat-route idea can simplify the implementation and aligns perfectly with the overall theme of The Standard. Keeping things simple."),(0,r.kt)("h3",{id:"31121-codes--responses"},"3.1.1.2.1 Codes & Responses"),(0,r.kt)("p",null,"Responses from an API controller must be mapped towards codes and responses. For instance, if we are trying to add a new student to a schooling system. We are going to ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," student and in retrun we receive the same body we submitted with a status code ",(0,r.kt)("inlineCode",{parentName:"p"},"201")," which means the resoruce has been ",(0,r.kt)("inlineCode",{parentName:"p"},"Created"),". "),(0,r.kt)("p",null,"There are three main categories where responses can fall into. The first is the success category. Where both the user and the server have done their part and the request has succeeded. The second category is the User Error Codes, where the user request has an issue of any type. In which case a ",(0,r.kt)("inlineCode",{parentName:"p"},"4xx")," code will be returned with detailed error message to help users fix their requests for perform a successful operation. The third case is the System Error Codes, where the system has run into an issue of any type internal or external and it needs to communicate a ",(0,r.kt)("inlineCode",{parentName:"p"},"5xx")," code to indicate to the user that something internally have gone wrong with the system and they need to contact support."),(0,r.kt)("p",null,"Let's talk about those codes and their scenarios in details here."),(0,r.kt)("h4",{id:"311210-success-codes-2xx"},"3.1.1.2.1.0 Success Codes (2xx)"),(0,r.kt)("p",null,"Success codes either indicates a resource has been created, updated, deleted or retreived. And some cases it indicates that a request has been submitted successfully in an eventual-consistency manner that may or may not succeed in the future. Here's the details for each:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Code"),(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Details"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"200"),(0,r.kt)("td",{parentName:"tr",align:null},"Ok"),(0,r.kt)("td",{parentName:"tr",align:null},"Used for successful GET, PUT and DELETE operations.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"201"),(0,r.kt)("td",{parentName:"tr",align:null},"Created"),(0,r.kt)("td",{parentName:"tr",align:null},"Used for successful POST operations")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"202"),(0,r.kt)("td",{parentName:"tr",align:null},"Accepted"),(0,r.kt)("td",{parentName:"tr",align:null},"Used for request that was delegated but may or may not succeed")))),(0,r.kt)("p",null,"Here's some examples for each:"),(0,r.kt)("p",null,"In a retrieve non-post scenario, it's more befitting to return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," status code as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet("{studentId}")]\npublic async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)\n{\n    Student retrievedStudent = \n        await this.studentService.RetrieveStudentByIdAsync(studentId);\n\n    return Ok(retrievedStudent);\n}\n')),(0,r.kt)("p",null,"But in a scenario where we have to create a resource, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Created")," is more befitting for this case as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[HttpPost)]\npublic async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)\n{\n    Student retrievedStudent = \n        await this.studentService.AddStudentAsync(student);\n\n    return Created(student);\n}\n")),(0,r.kt)("p",null,"In eventual consistency cases, where a resource posted isn't really persisted yet, we enqueue the request and return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Accepted")," status to indicate a process will start:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[HttpPost)]\npublic async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)\n{\n    Student retrievedStudent = \n        await this.studentEventService.EnqueueStudentEventAsync(student);\n\n    return Accepted(student);\n}\n")),(0,r.kt)("p",null,"The Standard rule for eventual consistency scenarios is to ensure the submitter has a token of some type so requestors can inquire about the status of their request with a different API call. We will discuss these patterns in a different book called The Standard Architecture."),(0,r.kt)("h4",{id:"311211-user-error-codes-4xx"},"3.1.1.2.1.1 User Error Codes (4xx)"),(0,r.kt)("p",null,"This is the second category of API responses. Where a user request has an issue in it and the system is required to help the user understand why their request was not successful. For instance, assume a client is submitting a new student to a schooling system. If the student Id is invalid a ",(0,r.kt)("inlineCode",{parentName:"p"},"400")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Bad Request")," code should be returned with a problem detail that explains what exactly is the reason for the failure of the request."),(0,r.kt)("p",null,"Controllers are responsible for mapping the core layer categorical exceptions into proper status codes. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet("{studentId}")]\npublic async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)\n{\n    try\n    {\n        ...\n    }\n    catch (StudentValidationException studentValidationException)\n    {\n        return BadRequest(studentValidationException.InnerException)\n    }\n}\n')),(0,r.kt)("p",null,"So as shown in this code snippet, we caught a categorical validation exception and mapped it into a ",(0,r.kt)("inlineCode",{parentName:"p"},"400")," error code which is ",(0,r.kt)("inlineCode",{parentName:"p"},"BadRequest"),". The access to inner exception here is for the purpose of extracting a problem detail out of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Data")," property on the inner exception which contains all the dictionary values of the error report."),(0,r.kt)("p",null,"But sometimes controllers have to dig deeper. Catching a particular local exception not just the categorical. For instance, say we want to handle ",(0,r.kt)("inlineCode",{parentName:"p"},"NotFoundStudentException")," with an error code ",(0,r.kt)("inlineCode",{parentName:"p"},"404")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"NotFound"),". Here's how we would accomplish that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet("{studentId}")]\npublic async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)\n{\n    try\n    {\n        ...\n    }\n    catch (StudentValidationException studentValidationException)\n        (when studentValidationException.InnerException is NotFoundStudentException)\n    {\n        return NotFound(studentValidationException.InnerException)\n    }\n}\n')),(0,r.kt)("p",null,"In the code snippet above, we had to examine the inner exception type to validate the localized exception from within. This is the advantage of the unwrapping and wrapping process we discussed in section 2.3.3.0.2 of The Standard. Controller may examine multiple types within the same block as well as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    ...\n    catch (StudentCoordinationDependencyValidationException studentCoordinationDependencyValidationException)\n        (when studentValidationException.InnerException \n            is NotFoundStudentException\n            or NotFoundLibraryCardException\n            or NotFoundStudentContactException)\n    {\n        return NotFound(studentValidationException.InnerException)\n    }\n    ...\n")),(0,r.kt)("p",null,"With that in mind, let's detail the most common mappings from exceptions to codes:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Code"),(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Exception"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"400"),(0,r.kt)("td",{parentName:"tr",align:null},"BadRequest"),(0,r.kt)("td",{parentName:"tr",align:null},"ValidationException or DependencyValidationException")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"404"),(0,r.kt)("td",{parentName:"tr",align:null},"NotFound"),(0,r.kt)("td",{parentName:"tr",align:null},"NotFoundException")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"409"),(0,r.kt)("td",{parentName:"tr",align:null},"Conflict"),(0,r.kt)("td",{parentName:"tr",align:null},"AlreadyExistException")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"423"),(0,r.kt)("td",{parentName:"tr",align:null},"Locked"),(0,r.kt)("td",{parentName:"tr",align:null},"LockedException")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"424"),(0,r.kt)("td",{parentName:"tr",align:null},"FailedDependency"),(0,r.kt)("td",{parentName:"tr",align:null},"InvalidReferenceException")))),(0,r.kt)("p",null,"There are more ",(0,r.kt)("inlineCode",{parentName:"p"},"4xx")," status codes out there. But As of this very moment they can either be automatically generated by the web framework like in ASP.NET or there are no useful scenarios for them yet. For instance, a ",(0,r.kt)("inlineCode",{parentName:"p"},"401")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Unauthorized")," error can be automatically generated if the controller endpoint is decorated with authorization requirement."),(0,r.kt)("h4",{id:"311212-system-error-codes-5xx"},"3.1.1.2.1.2 System Error Codes (5xx)"),(0,r.kt)("p",null,"System error codes are the third and last possible type of codes that may occur or be returned from an API endpoint. Their main responsibility is to indicate in general that the consumer of the API endpoint is at no fault. Something bad happened in the system, and the engineering team is required to get involved to resolve the issue. That's why we log our exceptions with a severity level at the core business logic layer so we know how urgent the matter may be."),(0,r.kt)("p",null,"The most common http code that can be communicated on a server-side issue is the ",(0,r.kt)("inlineCode",{parentName:"p"},"500")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"InternalServerError")," code. Let's take a look at a code snippet that deals with this situation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet("{studentId}")]\npublic async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)\n{\n    try\n    {\n        ...\n    }\n    ...\n    catch (StudentDependencyException studentDependencyException)\n    {\n        return InternalServerError(studentValidationException)\n    }\n}\n')),(0,r.kt)("p",null,"In the above snippet we completely ignored the inner exception and mainly focused on the categorical exception for security reasons. Mainly to not allow internal server information to be exposed in an API response other than something as simple as ",(0,r.kt)("inlineCode",{parentName:"p"},"Dependency error occurred, contact support.")," Since the consumer of the API is required to perform no action whatsoever other than creating a ticket for the support team."),(0,r.kt)("p",null,"Ideally, these issues should be caught out of Acceptance Tests which we will discuss shortly in this chapter. But there are times where there's a server blip that may cause a memory leakage of some sort or any other internal infrastrucrual issues that won't be caught by end-to-end testing in any way."),(0,r.kt)("p",null,"In terms of types of exceptions that may be handled, it's a little smaller when it comes server error here's the details:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Code"),(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Exception"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"500"),(0,r.kt)("td",{parentName:"tr",align:null},"InternalServerError"),(0,r.kt)("td",{parentName:"tr",align:null},"DependencyException or ServiceException")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"507"),(0,r.kt)("td",{parentName:"tr",align:null},"NotFound"),(0,r.kt)("td",{parentName:"tr",align:null},"InsufficientStorageException (Internal Only)")))),(0,r.kt)("p",null,"There's also an interesting case where two teams agree on a certain swagger document, and the back-end API development team decides to build corresponding API endpoints with methods that are not yet implemented to communicate to the other team that the work hasn't started yet. In which case using error code ",(0,r.kt)("inlineCode",{parentName:"p"},"501")," is sufficient which is just a code for ",(0,r.kt)("inlineCode",{parentName:"p"},"NotImplemented"),"."),(0,r.kt)("p",null,"It is also important to mention that the native ",(0,r.kt)("inlineCode",{parentName:"p"},"500")," error code can be communicated in ASP.NET applications through ",(0,r.kt)("inlineCode",{parentName:"p"},"Problem")," method. We are relying on a library ",(0,r.kt)("inlineCode",{parentName:"p"},"RESTFulSense")," to provide more codes than the native implementation can offer, but more importantly provide a problem detail serialization option and deserialization option on the client side."),(0,r.kt)("h4",{id:"311213-all-codes"},"3.1.1.2.1.3 All Codes"),(0,r.kt)("p",null,"Other than the ones mentioned in previous sections, and for documentation purposes, here's the all of the ",(0,r.kt)("inlineCode",{parentName:"p"},"4xx")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"5xx")," codes an API could communicate according to the latest standardized API guidelines:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Status"),(0,r.kt)("th",{parentName:"tr",align:null},"Code"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BadRequest"),(0,r.kt)("td",{parentName:"tr",align:null},"400")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Unauthorized"),(0,r.kt)("td",{parentName:"tr",align:null},"401")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PaymentRequired"),(0,r.kt)("td",{parentName:"tr",align:null},"402")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Forbidden"),(0,r.kt)("td",{parentName:"tr",align:null},"403")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NotFound"),(0,r.kt)("td",{parentName:"tr",align:null},"404")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NotFound"),(0,r.kt)("td",{parentName:"tr",align:null},"404")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MethodNotAllowed"),(0,r.kt)("td",{parentName:"tr",align:null},"405")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NotAcceptable"),(0,r.kt)("td",{parentName:"tr",align:null},"406")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ProxyAuthenticationRequired"),(0,r.kt)("td",{parentName:"tr",align:null},"407")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RequestTimeout"),(0,r.kt)("td",{parentName:"tr",align:null},"408")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Conflict"),(0,r.kt)("td",{parentName:"tr",align:null},"409")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Gone"),(0,r.kt)("td",{parentName:"tr",align:null},"410")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LengthRequired"),(0,r.kt)("td",{parentName:"tr",align:null},"411")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PreconditionFailed"),(0,r.kt)("td",{parentName:"tr",align:null},"412")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RequestEntityTooLarge"),(0,r.kt)("td",{parentName:"tr",align:null},"413")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RequestUriTooLong"),(0,r.kt)("td",{parentName:"tr",align:null},"414")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnsupportedMediaType"),(0,r.kt)("td",{parentName:"tr",align:null},"415")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RequestedRangeNotSatisfiable"),(0,r.kt)("td",{parentName:"tr",align:null},"416")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ExpectationFailed"),(0,r.kt)("td",{parentName:"tr",align:null},"417")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MisdirectedRequest"),(0,r.kt)("td",{parentName:"tr",align:null},"421")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnprocessableEntity"),(0,r.kt)("td",{parentName:"tr",align:null},"422")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Locked"),(0,r.kt)("td",{parentName:"tr",align:null},"423")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FailedDependency"),(0,r.kt)("td",{parentName:"tr",align:null},"424")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UpgradeRequired"),(0,r.kt)("td",{parentName:"tr",align:null},"426")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PreconditionRequired"),(0,r.kt)("td",{parentName:"tr",align:null},"428")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TooManyRequests"),(0,r.kt)("td",{parentName:"tr",align:null},"429")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RequestHeaderFieldsTooLarge"),(0,r.kt)("td",{parentName:"tr",align:null},"431")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnavailableForLegalReasons"),(0,r.kt)("td",{parentName:"tr",align:null},"451")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"InternalServerError"),(0,r.kt)("td",{parentName:"tr",align:null},"500")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NotImplemented"),(0,r.kt)("td",{parentName:"tr",align:null},"501")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BadGateway"),(0,r.kt)("td",{parentName:"tr",align:null},"502")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ServiceUnavailable"),(0,r.kt)("td",{parentName:"tr",align:null},"503")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GatewayTimeout"),(0,r.kt)("td",{parentName:"tr",align:null},"504")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HttpVersionNotSupported"),(0,r.kt)("td",{parentName:"tr",align:null},"505")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"VariantAlsoNegotiates"),(0,r.kt)("td",{parentName:"tr",align:null},"506")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"InsufficientStorage"),(0,r.kt)("td",{parentName:"tr",align:null},"507")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LoopDetected"),(0,r.kt)("td",{parentName:"tr",align:null},"508")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NotExtended"),(0,r.kt)("td",{parentName:"tr",align:null},"510")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NetworkAuthenticationRequired"),(0,r.kt)("td",{parentName:"tr",align:null},"511")))),(0,r.kt)("p",null,"We will explore incorporating some of these codes in future revisions of The Standard as needed."),(0,r.kt)("h3",{id:"31122-single-dependency"},"3.1.1.2.2 Single Dependency"),(0,r.kt)("p",null,"Exposer components can have one and only one dependency. This dependency must be a Service component. it cannot be a Broker or any other native dependency that Brokers may use to pull configurations or any other type of dependencies."),(0,r.kt)("p",null,"When implementing a controller, the constructor can be implemented as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[ApiController]\n[Route("api/[controller]")]\npublic class StudentsController : RESTFulController\n{\n    private readonly IStudentService studentService;\n\n    public StudentsController(IStudentService studentService) =>\n        this.studentService = studentService;\n\n    ...\n    ...\n}\n')),(0,r.kt)("h3",{id:"31123-single-contract"},"3.1.1.2.3 Single Contract"),(0,r.kt)("p",null,"This charactristic comes out of the box with the single dependency rule. If Services can only serve and receive one contract then the same rule will apply to controllers. They can return a contract, a list of objects with the same contract or portion of the contract when passing in Ids or queries."),(0,r.kt)("h2",{id:"3113-organization"},"3.1.1.3 Organization"),(0,r.kt)("p",null,"Controllers should be located under ",(0,r.kt)("inlineCode",{parentName:"p"},"Controllers")," folder and belong within a ",(0,r.kt)("inlineCode",{parentName:"p"},"Controllers")," namespace. Controller do not need to have their own folders or namespaces as they perform a simple exposure task and that's all."),(0,r.kt)("p",null,"Here's an example of a controller namespace:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'namespace GitFyle.Core.Api.Controllers\n{\n    [ApiController]\n    [Route("api/[controller]")]\n    public class ContributionsController : RESTFulController\n    {\n        ...\n    }\n}\n')),(0,r.kt)("h2",{id:"3114-home-controller"},"3.1.1.4 Home Controller"),(0,r.kt)("p",null,"Every system should implement an API endpoint that we call ",(0,r.kt)("inlineCode",{parentName:"p"},"HomeController"),". The controller only responsibility is to return a simple message to indicate that the API is still alive. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'using Microsoft.AspNetCore.Mvc;\n\nnamespace OtripleS.Web.Api.Controllers\n{\n    [ApiController]\n    [Route("api/[controller]")]\n    public class HomeController : ControllerBase\n    {\n        [HttpGet]\n        public ActionResult<string> Get() =>\n            Ok("Hello Mario, the princess is in another castle!");\n    }\n}\n')),(0,r.kt)("p",null,"Home controllers are not required to have any security on them. They open a gate for heartbeat tests to ensure the system as an entity is running without checking any external dependencies. This practice is very important to help engineers know when the system is down and quickly act on it."),(0,r.kt)("h2",{id:"3115-tests"},"3.1.1.5 Tests"),(0,r.kt)("p",null,"Controllers can be potentially unit tested to verify the mapping of exceptions to error codes are in place. But that's not a pattern I have been following myself so far. However, what is more important is Acceptance tests. Which verify all the components of the system are fully and successfully integrated with one another."),(0,r.kt)("p",null,"Here's an example of an acceptance test:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[Fact]\npublic async Task ShouldPostStudentAsync()\n{\n    // given\n    Student randomStudent = CreateRandomStudent();\n    Student inputStudent = randomStudent;\n    Student expectedStudent = inputStudent;\n\n    // when \n    await this.otripleSApiBroker.PostStudentAsync(inputStudent);\n\n    Student actualStudent =\n        await this.otripleSApiBroker.GetStudentByIdAsync(inputStudent.Id);\n\n    // then\n    actualStudent.Should().BeEquivalentTo(expectedStudent);\n    await this.otripleSApiBroker.DeleteStudentByIdAsync(actualStudent.Id);\n}\n")),(0,r.kt)("p",null,"Acceptance tests are required to cover every available endpoint on a controller. They are also responsible for cleaning up any test data after the test is completed. It is also important to mention that resources that are not owned by the microservice like database, must be emulated with applications such as ",(0,r.kt)("inlineCode",{parentName:"p"},"WireMock")," and many others."),(0,r.kt)("p",null,"Acceptance tests are also implemented after the fact unlike unit tests. An endpoint has to be fully integrated and functional before a test is written to ensure the success of implementation is in place."),(0,r.kt)("p",null,"[*][Acceptance Tests (Part 1)]","(",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=WWN-9ahbdIU"},"https://www.youtube.com/watch?v=WWN-9ahbdIU"),")"),(0,r.kt)("p",null,"[*][Acceptance Tests (Part 2)]","(",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=ANqj9pldfso"},"https://www.youtube.com/watch?v=ANqj9pldfso"),")"))}p.isMDXComponent=!0}}]);