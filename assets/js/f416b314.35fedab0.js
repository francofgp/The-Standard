"use strict";(self.webpackChunkthe_standard=self.webpackChunkthe_standard||[]).push([[3881],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,m=c["".concat(l,".").concat(h)]||c[h]||p[h]||o;return n?a.createElement(m,r(r({ref:t},u),{},{components:n})):a.createElement(m,r({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4065:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const o={},r="2.1 Foundation Services (Broker-Neighboring)",s={unversionedId:"Services/2.1 Foundations/2.1 Foundations",id:"Services/2.1 Foundations/2.1 Foundations",title:"2.1 Foundation Services (Broker-Neighboring)",description:"2.1.0 Introduction",source:"@site/docs/2. Services/2.1 Foundations/2.1 Foundations.md",sourceDirName:"2. Services/2.1 Foundations",slug:"/Services/2.1 Foundations/",permalink:"/The-Standard/docs/Services/2.1 Foundations/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/2. Services/2.1 Foundations/2.1 Foundations.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2 Services",permalink:"/The-Standard/docs/Services/"},next:{title:"2.2 Processing Services (Higher-Order Business Logic)",permalink:"/The-Standard/docs/Services/2.2 Processings/"}},l={},d=[{value:"2.1.0 Introduction",id:"210-introduction",level:2},{value:"2.1.1 On The Map",id:"211-on-the-map",level:2},{value:"2.1.2 Characteristics",id:"212-characteristics",level:2},{value:"2.1.2.0 Pure-Primitive",id:"2120-pure-primitive",level:3},{value:"2.1.2.1 Single Entity Integration",id:"2121-single-entity-integration",level:3},{value:"2.1.2.2 Business Language",id:"2122-business-language",level:3},{value:"2.1.3 Responsibilities",id:"213-responsibilities",level:2},{value:"2.1.3.0 Abstraction",id:"2130-abstraction",level:3},{value:"2.1.3.0.1 Implementation",id:"21301-implementation",level:4},{value:"2.1.3.1 Validation",id:"2131-validation",level:3},{value:"2.1.3.1.0 Circuit-Breaking Validations",id:"21310-circuit-breaking-validations",level:4},{value:"2.1.3.1.1 Continuous Validations",id:"21311-continuous-validations",level:4},{value:"2.1.3.1.1.0 Upsertable Exceptions",id:"213110-upsertable-exceptions",level:4},{value:"2.1.3.1.1.1 Dynamic Rules",id:"213111-dynamic-rules",level:4},{value:"2.1.3.1.1.2 Rules &amp; Validations Collector",id:"213112-rules--validations-collector",level:4},{value:"2.1.3.1.2 Structural Validations",id:"21312-structural-validations",level:4},{value:"2.1.3.1.2.0 Testing Structural Validations",id:"213120-testing-structural-validations",level:5},{value:"2.1.3.1.2.1 Implementing Structural Validations",id:"213121-implementing-structural-validations",level:5},{value:"StudentService.Validations.cs",id:"studentservicevalidationscs",level:6},{value:"StudentService.cs",id:"studentservicecs",level:6},{value:"StudentService.Exceptions.cs",id:"studentserviceexceptionscs",level:6},{value:"2.1.3.1.3 Logical Validations",id:"21313-logical-validations",level:4},{value:"2.1.3.1.3.0 Testing Logical Validations",id:"213130-testing-logical-validations",level:5},{value:"2.1.3.1.3.1 Implementing Logical Validations",id:"213131-implementing-logical-validations",level:5},{value:"StudentService.Validations.cs",id:"studentservicevalidationscs-1",level:6},{value:"2.1.3.1.4 External Validations",id:"21314-external-validations",level:4},{value:"2.1.3.1.4.0 Testing External Validations",id:"213140-testing-external-validations",level:5},{value:"2.1.3.1.4.1 Implementing External Validations",id:"213141-implementing-external-validations",level:5},{value:"StudentService.Validations.cs",id:"studentservicevalidationscs-2",level:6},{value:"StudentService.Exceptions.cs",id:"studentserviceexceptionscs-1",level:6},{value:"StudentService.cs",id:"studentservicecs-1",level:6},{value:"2.1.3.1.5 Dependency Validations",id:"21315-dependency-validations",level:4},{value:"2.1.3.1.5.0 Testing Dependency Validations",id:"213150-testing-dependency-validations",level:5},{value:"2.1.3.0.5.1 Implementing Dependency Validations",id:"213051-implementing-dependency-validations",level:5},{value:"StudentService.Exceptions.cs",id:"studentserviceexceptionscs-2",level:6},{value:"2.1.3.2 Mapping",id:"2132-mapping",level:3},{value:"2.1.3.2.0 Non-Local Models",id:"21320-non-local-models",level:4},{value:"2.1.3.2.1 Exceptions Mappings",id:"21321-exceptions-mappings",level:4}],u={toc:d};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"21-foundation-services-broker-neighboring"},"2.1 Foundation Services (Broker-Neighboring)"),(0,i.kt)("h2",{id:"210-introduction"},"2.1.0 Introduction"),(0,i.kt)("p",null,"Foundation services are the first point of contact between your business logic and the brokers."),(0,i.kt)("p",null,"In general, the broker-neighboring services are a hybrid of business logic and an abstraction layer for the processing operations where the higher-order business logic happens, which we will talk about further when we start exploring the processing services in the next section."),(0,i.kt)("p",null,"Broker-neighboring services main responsibility is to ensure the incoming and outgoing data through the system is validated and vetted structurally, logically and externally."),(0,i.kt)("p",null,"You can also think of broker-neighboring services as a layer of validation on top of the primitive operations the brokers already offer."),(0,i.kt)("p",null,"For instance, if a storage broker is offering ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertStudentAsync(Student student)")," as a method, then the broker-neighboring service will offer something as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> AddStudentAsync(Student student)\n{\n    ValidateStudent(student);\n\n    return await this.storageBroker.InsertStudentAsync(student);\n}\n")),(0,i.kt)("p",null,"This makes broker-neighboring services nothing more than an extra layer of validation on top of the existing primitive operations brokers already offer."),(0,i.kt)("h2",{id:"211-on-the-map"},"2.1.1 On The Map"),(0,i.kt)("p",null,"The broker-neighboring services reside between your brokers and the rest of your application, on the left side higher-order business logic processing services, orchestration, coordination, aggregation or management services may live, or just simply a controller, a UI component or any other data exposure technology."),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/100716772-00eec800-336e-11eb-9064-8bfe2f8e3be2.png"})),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"212-characteristics"},"2.1.2 Characteristics"),(0,i.kt)("p",null,"Foundation or Broker-Neighboring services in general have very specific characteristics that strictly govern their development and integration."),(0,i.kt)("p",null,"Foundation services in general focus more on validations than anything else - simply because that's their purpose, to ensure all incoming and outgoing data through the system is in a good state for the system to process it safely without any issues."),(0,i.kt)("p",null,"Here's the characteristics and rules that govern broker-neighboring services:"),(0,i.kt)("h3",{id:"2120-pure-primitive"},"2.1.2.0 Pure-Primitive"),(0,i.kt)("p",null,"Broker-neighboring services are not allowed to combine multiple primitive operations to achieve a higher-order business logic operation."),(0,i.kt)("p",null,"For instance, broker-neighboring services cannot offer an ",(0,i.kt)("em",{parentName:"p"},"upsert")," function, to combine a ",(0,i.kt)("inlineCode",{parentName:"p"},"Select")," operations with an ",(0,i.kt)("inlineCode",{parentName:"p"},"Update")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Insert")," operations based on the outcome to ensure an entity exists and is up to date in any storage."),(0,i.kt)("p",null,"But they offer a validation and exception handling (and mapping) wrapper around the dependency calls, here's an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public ValueTask<Student> AddStudentAsync(Student student) =>\nTryCatch(async () =>\n{\n    ValidateStudent(student);\n\n    return await this.storageBroker.InsertStudentAsync(student);\n});\n")),(0,i.kt)("p",null,"In the above method, you can see ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateStudent")," function call preceded by a ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," block.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," block is what I call Exception Noise Cancellation pattern, which we will discuss soon in this very section."),(0,i.kt)("p",null,"But the validation function ensures each and every property in the incoming data is validated before passing it forward to the primitive broker operation, which is the ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertStudentAsync")," in this very instance."),(0,i.kt)("h3",{id:"2121-single-entity-integration"},"2.1.2.1 Single Entity Integration"),(0,i.kt)("p",null,"Services strongly ensure the single responsibility principle is implemented by not integrating with any other entity brokers except for the one that it supports."),(0,i.kt)("p",null,"This rule doesn't necessarily apply to support brokers like ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTimeBroker")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"LoggingBroker")," since they don't specifically target any particular business entity and they are almost generic across the entire system."),(0,i.kt)("p",null,"For instance, a ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService")," may integrate with a ",(0,i.kt)("inlineCode",{parentName:"p"},"StorageBroker")," as long as it only targets only the functionality offered by the partial class in the ",(0,i.kt)("inlineCode",{parentName:"p"},"StorageBroker.Students.cs")," file."),(0,i.kt)("p",null,"Foundation services should not integrate with more than one entity broker of any kind simply because it will increase the complexity of validation and orchestration which goes beyond the main purpose of the service which is just simply validation. We push this responsibility further to the orchestration-type services to handle it."),(0,i.kt)("h3",{id:"2122-business-language"},"2.1.2.2 Business Language"),(0,i.kt)("p",null,"Broker-neighboring services speak primitive business language for their operations.\nFor instance, while a Broker may provide a method with the name ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertStudentAsync")," - the equivelant of that on the service layer would be ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStudentAsync"),"."),(0,i.kt)("p",null,"In general, most of the CRUD operations shall be converted from a storage lanaugage to a business language, and the same goes for non-storage operations such as Queues, for instance we say ",(0,i.kt)("inlineCode",{parentName:"p"},"PostQueueMessage")," but on the business layer we shall say ",(0,i.kt)("inlineCode",{parentName:"p"},"EnqueueMessage"),"."),(0,i.kt)("p",null,"Since the CRUD operations the most common ones in every system, our mapping to these CRUD operations would be as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Brokers"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Services"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Insert"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Add")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Select"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Retrieve")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Update"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Modify")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Delete"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Remove")))),(0,i.kt)("p",null,"As we move forward towards higher-order business logic services, the language of the methods beings used will lean more towards a business language rather than a technology language as we will see in the upcoming sections."),(0,i.kt)("h2",{id:"213-responsibilities"},"2.1.3 Responsibilities"),(0,i.kt)("p",null,"Broker-neighboring services play three very important roles in any system.\nThe first role is to abstract away native broker operations from the rest of the system. Irregardless of whether a broker is a communication between a local or external storage or an API - broker-neighboring services will always have the same contract/verbiage to expose to upper stream services such as processing, orchestration or simply exposers like controllers or UI components.\nThe second and most important role is to offer a layer of validation on top of the existing primitive operations a broker already offers to ensure incoming and outgoing data is valid to be processed or persisted by the system.\nThe third role is to play the role of a mapper of all other native models and contracts that may be needed to completed any given operation while interfacing with a broker.\nFoundation services are the last point of abstraction between the core business logic of any system and the rest of the world, let's discuss these roles in detail."),(0,i.kt)("h3",{id:"2130-abstraction"},"2.1.3.0 Abstraction"),(0,i.kt)("p",null,"The first and most important responsibility for foundation/broker-neighboring services is to ensure a level of abstraction exists between the brokers and the rest of your system. This abstraction is necessary to ensure the pure business logic layer in any system is verbally and functionally agnostic to whichever dependencies the system is relying on to communicate with the outside world."),(0,i.kt)("p",null,"Let's visualize a concrete example of the above principle. Let's assume we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentProcessingService")," which implements an ",(0,i.kt)("inlineCode",{parentName:"p"},"UpsertStudentAsync")," functionality. Somewhere in that implementation there will be a dependency on ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStudentAsync")," which is exposed and implemented by some ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService")," as a foundation service. Take a look at this snippet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> UpsertStudentAsync(Student student)\n{\n    ...\n\n    return await this.studentService.AddStudentAsync(student);\n}\n")),(0,i.kt)("p",null,"The contract between a processing or an orchestration service and a foundation service will always be the same irregardless of what type of implementation or what type of brokers the foundation service is using.\nFor example, ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStudentAsync")," could be a call to a database or an API endpoint or simply putting a message on a queue. It all doesn't impact in any way, shape or form the upstream processing service implementation. here's an example of three different implementations of a foundation service that wouldn't change anything in the implementation of it's upstream services:"),(0,i.kt)("p",null,"With a storage broker:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> AddStudentAsync(Student student)\n{\n    ...\n    return await this.storageBroker.InsertStudentAsync(student);\n}\n")),(0,i.kt)("p",null,"Or with a queue broker:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> AddStudentAsync(Student student)\n{\n    ...\n\n    return await this.queueBroker.EnqueueStudentAsync(student);\n}\n")),(0,i.kt)("p",null,"or with an API broker:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> AddStudentAsync(Student student)\n{\n    ...\n\n    return await this.apiBroker.PostStudentAsync(student);\n}\n")),(0,i.kt)("p",null,"here's a visualization of that concept:"),(0,i.kt)("br",null),(0,i.kt)("div",null,(0,i.kt)("img",{width:"75%",src:"https://user-images.githubusercontent.com/1453985/128610577-ee926ee2-a589-4f77-bf9d-dbff63d1c20d.png"})),(0,i.kt)("br",null),(0,i.kt)("p",null,"In all of these above cases, the underlying implementation may change, but the exposed contract will always stay the same for the rest of the system. We will discuss in later chapters how the core, agnostic and abstreact business logic of your system starts with Processing services and ends with Management or Aggregation services."),(0,i.kt)("h4",{id:"21301-implementation"},"2.1.3.0.1 Implementation"),(0,i.kt)("p",null,"Let's talk about a real-life example of implementing a simple ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," function in a foundation service. Let's assume we have the following contract for our ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public IStudentService\n{\n    ValueTask<Student> AddStudentAsync(Student student);\n}\n")),(0,i.kt)("p",null,"For starters, let's go ahead and write a failing test for our service as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async Task ShouldAddStudentAsync()\n{\n    // given\n    Student randomStudent = CreateRandomStudent();\n    Student inputStudent = randomStudent;\n    Student storageStudent = inputStudent;\n    Student expectedStudent = storageStudent.DeepClone();\n\n    this.storageBrokerMock.Setup(broker =>\n        broker.InsertStudentAsync(inputStudent))\n            .ReturnsAsync(storageStudent);\n\n    // when\n    Student actualStudent =\n        await this.studentService.AddStudentAsync(inputStudent);\n\n    // then\n    actualStudent.Should().BeEquivalentTo(expectedStudent);\n\n    this.storageBroker.Verify(broker =>\n        broker.InsertStudentAsync(inputStudent),\n            Times.Once);\n\n    this.storageBroker.VerifyNoOtherCalls();\n    this.loggingBroker.VerifyNoOtherCalls();\n}\n")),(0,i.kt)("p",null,"In the above test, we defined four variables with the same value. Each variable contains a name that best fits the context it will be used in. For instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"inputStudent")," best fits in the input parameter position, while ",(0,i.kt)("inlineCode",{parentName:"p"},"storageStudent")," best first what gets returned from the storage broker after a student is persisted sucessfully."),(0,i.kt)("p",null,"You will also notice that we deep cloned the ",(0,i.kt)("inlineCode",{parentName:"p"},"expectedStudent")," variable to ensure no modifications have happened to the originally passed in student. For instance, assume an input student value has changed for any of it's attributes internally within the ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStudentAsync")," function. That change won't trigger a failing test unless we dereference the ",(0,i.kt)("inlineCode",{parentName:"p"},"expectedStudent")," variable from the input and returned variables."),(0,i.kt)("p",null,"We mock the response from the storage broker and execute our subject of test ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStudentAsync")," then we verify the returned student value ",(0,i.kt)("inlineCode",{parentName:"p"},"actualStudent")," matches the expected value ",(0,i.kt)("inlineCode",{parentName:"p"},"expectedStudent")," regardless of the reference."),(0,i.kt)("p",null,"Finally, we verify all calls are done properly and no additional calls has been made to any of the service dependencies."),(0,i.kt)("p",null,"Let's make that test pass by writing in an implementation that only satisfies the requirements of the aforementioned test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> AddStudentAsync(Student student) =>\n    await this.storageBroker.InsertStudentAsync(student);\n")),(0,i.kt)("p",null,"This simple implementation should make our test pass sucessfully. It's important to understand that any implementation should be only enough to pass the failing tests. Nothing more and nothing less."),(0,i.kt)("h3",{id:"2131-validation"},"2.1.3.1 Validation"),(0,i.kt)("p",null,"Foundation services are required to ensure incoming and outgoing data from and to the system are in a good state - they play the role of a gatekeeper between the system and the outside world to ensure the data that goes through is structurally, logically and externally valid before performing any further operations by upstream services.\nThe order of validations here is very intentional. Structural validations are the cheapest of all three types. They ensure a particular attribute or piece of data in general doesn't have a default value if it's required. the opposite of that is the logical validations, where attributes are compared to other attributes with the same entity or any other. Additional logical validations can also include a comparison with a constant value like comparing a student enrollment age to be no less than 5 years of age.\nBoth strucural and logical validations come before the external. As we said, it's simply because we don't want to pay the cost of communicating with an external resource including latency tax if our request is not in a good shape first.\nFor instance, we shouldn't try to post some ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," object to an external API if the object is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". Or if the ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," model is invalid structurally or logically."),(0,i.kt)("p",null,"For all types of validations, it's important to understand that some validations are circuit-breaking or requiring an immediate exit from the current flow by throwing an exception or returning a value in some cases. And some other validations are continuous. Let's talk about these two sub categories of validations first."),(0,i.kt)("h4",{id:"21310-circuit-breaking-validations"},"2.1.3.1.0 Circuit-Breaking Validations"),(0,i.kt)("p",null,"Circuit-breaking validations require an immediate exit from the current flow. For instance, if an object being passed into a function is ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," - there will be no further operations required at that level other than exiting the current flow by throwing an exception or returning a value of some type. Here's an example:\nIn some validation scenario, assume that our ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStudent")," function has a student of value ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," passed into it as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Student noStudent = null;\n\nawait this.studentService.AddStudentAsync(noStudent);\n")),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStudentAsync")," function in this scenario is now required to validate whether the passed in parameter is ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or not before going any further with any other type of validations or the business logic itself. Something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public Student AddStudentAsync(Student student) =>\nTryCatch(async () =>\n{\n    ValidateStudent(student);\n\n    return await this.storageBroker.InsertStudentAsync(student);\n});\n")),(0,i.kt)("p",null,"The statement in focus here is ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateStudent")," function and what it does. Here's an example of how that routine would be implemented:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"private void ValidateStudent(Student student)\n{\n    if(student is null)\n    {\n        throw new NullStudentException();\n    }\n}\n")),(0,i.kt)("p",null,"In the function above, we decided to throw the exception immediately instead of going in further. That's an example of circuit-breaking validation type."),(0,i.kt)("p",null,"But with validations, circuit-breaking isn't always the wise thing to do. Sometimes we want to collect all the issues within a particular request before sending the error report back to the request submitter. Let's talk about that in this next section."),(0,i.kt)("h4",{id:"21311-continuous-validations"},"2.1.3.1.1 Continuous Validations"),(0,i.kt)("p",null,"Continuous validations are the opposite of circuit-breaking validations. They don't stop the flow of validations but they definitely stop the flow of logic. In other words, continuous validations ensure no business logic will be executed but they also ensure other validations of the same type can continue to execute before breaking the circuit. Let's materialize this theory with an example:\nAssume our student model looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Student\n{\n    public Guid Id {get; set;}\n    public string Name {get; set;}\n}\n")),(0,i.kt)("p",null,"Assuming that the passed in ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," model is not null, but it has default values across the board for all it's properties. We want to collect all these issues for however many attributes/properties this object has and return a full report back to the requestor. Here's how to do it."),(0,i.kt)("h4",{id:"213110-upsertable-exceptions"},"2.1.3.1.1.0 Upsertable Exceptions"),(0,i.kt)("p",null,"A problem of that type requires a special type of exceptions that allow collecting all errors in it's ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," property. Every native exception out there will contain the ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," property which is basically a dictionary for a key/value pairs for collecting more information about the issues that caused that exception to occur.\nThe issue with these native exceptions is that they don't have native support for upsertion. Being able to append to an existing list of values against a particular key at any point of time.\nHere's a native implementation of upserting values in some given dictionary:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var someException = new Exception();\n\nif(someException.Data.Contains(someKey))\n{\n    (someException.Data[someKey] as List<string>)?.Add(someValue);\n}\nelse\n{\n    someException.Data.Add(someKey, new List<string>{ someValue });\n}\n")),(0,i.kt)("p",null,"This implementation can be quite daunting for engineers to think about and test in their service-level implementation. It felt more appropriate to introduce a simple library ",(0,i.kt)("inlineCode",{parentName:"p"},"Xeptions")," to simplify the above implementation into something as simple as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var someException = new Xeption();\nsomeException.UpsertData(someKey, someValue);\n")),(0,i.kt)("p",null,"Now that we have this library to utilize, the concern of implementing upsertable exceptions has been addressed. This means that we have what it takes to collect our validation errors. But that's not good enough if we don't have a mechanism to break the circuit when we believe that the time is right to do so.\nWe can simply use the native offerings to implement the circuit-breaking directly as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"if(someException.Data.Count > 0)\n{\n    throw someException;\n}\n")),(0,i.kt)("p",null,"And while this can be easily baked into any existing implementation. It still didn't contribute much to overall look-n-feel of the code. Therefore I have decided to make it a part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Xeptions")," library to be simplified to the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"someException.ThrowIfContainsErrors();\n")),(0,i.kt)("p",null,"That would make our custom validations look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public class InvalidStudentException : Xeption\n{\n    public InvalidStudentException()\n        : base ("Student is invalid. Please fix the errors and try again.")\n    { }\n}\n')),(0,i.kt)("p",null,"But with continuous validations, the process of collecting these errors conveys more than just a special exception implementation. Let's talk about that in the next section."),(0,i.kt)("h4",{id:"213111-dynamic-rules"},"2.1.3.1.1.1 Dynamic Rules"),(0,i.kt)("p",null,"A non-circuit-breaking or continuous validation process will require the ability to pass in dynamic rules at any count or capacity to add these validation errors. A validation rule is a dynamic structure that reports whether the rule has been violated for its condition; and also the error message that should be reported to the end user to help them fix that issue."),(0,i.kt)("p",null,"In a scenario where we want to ensure any given Id is valid, a dynamic continuous validation rule would look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'private static dynamic IsInvalid(Guid id) => new\n{\n    Condition = id == Guid.Empty,\n    Message = "Id is required"\n};\n')),(0,i.kt)("p",null,"Now our Rule doesn't just report whether a particular attribute is invalid or not. It also has a meaningful human-readable message that helps the consumer of the service understand what makes that very attribute invalid."),(0,i.kt)("p",null,"It's really important to point out the language engineers must use for validation messages. It will all depend on the potential consumers of your system. A non-engineer will not understand a message such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Text cannot be null, empty or whitespace")," - ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," as a term isn't something that is very commonly used. Engineers must work closely with their meatware (The people using the system) to ensure the language makes sense to them."),(0,i.kt)("p",null,"Dynamic rules by design will allow engineers to modify both their inputs and outputs without breaking any existing functionality as long as ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," values are considered across the board. Here's another manifestation of a Dynamic Validation Rule:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'private static dynamic IsNotSame(\n    Guid firstId,\n    Guid secondId,\n    string secondIdName) => new\n{\n    Condition = firstId != secondId,\n    Message = $"Id is not the same as {secondIdName}.",\n    HelpLink = "/help/code1234"\n};\n')),(0,i.kt)("p",null,"Our dynamic rule now can offer more input parameters and more helpful information in terms of more detailed exception message with links to helpful documentation sites or references for error codes."),(0,i.kt)("h4",{id:"213112-rules--validations-collector"},"2.1.3.1.1.2 Rules & Validations Collector"),(0,i.kt)("p",null,"Now that have the advanced exceptions and the dynamic validation rules. It's time to put it all together in terms of accepting infinite number of validation rules, examining their condition results and finally break the circuit when all the continuous validations are done. here's how to do that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"private void Validate(params (dynamic Rule, string Parameter)[] validations)\n{\n    var invalidStudentException = new InvalidStudentException();\n\n    foreach((dynamic rule, string parameter) in validations)\n    {\n        if(rule.Condition)\n        {\n            invalidStudentException.UpsertData(parameter, rule.Message);\n        }\n    }\n\n    invalidStudentException.ThrowIfContainsErrors();\n}\n")),(0,i.kt)("p",null,"The above function now will take any number of validation rules, and the parameters the rule is running against then examine the conditions and upsert the report of errors. This is how we can use the method above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"private void ValidateStudent(Student student)\n{\n    Validate(\n        (Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)),\n        (Rule: IsInvalid(student.Name), Parameter: nameof(Student.name)),\n        (Rule: IsInvalid(student.Grade), Parameter: nameof(Student.Grade))\n    );\n}\n")),(0,i.kt)("p",null,"This simplification of writing the rules and validations is the ultimate goal of continuing to provide value to the end users while making the process of engineering the solution pleasant to the engineers themselves."),(0,i.kt)("p",null,"Now, let's dive deeper into the types of validations that our systems can offer and how to handle them."),(0,i.kt)("h4",{id:"21312-structural-validations"},"2.1.3.1.2 Structural Validations"),(0,i.kt)("p",null,"Validations are three different layers. the first of these layers is the structural validations. to ensure certain properties on any given model or a primitive type are not in an invalid structural state."),(0,i.kt)("p",null,"For instance, a property of type ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," should not be empty, ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or white space. another example would be for an input parameter of an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," type, it should not be at it's ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," state which is ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," when trying to enter an age for instance."),(0,i.kt)("p",null,"The structural validations ensure the data is in a good shape before moving forward with any further validations - for instance, we can't possibly validate a student has the minimum number of characters (which is a logical validation) in their names if their first name is structurally invalid structurally by being ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", empty or whitespace."),(0,i.kt)("p",null,"Structural validations play the role of identifying the ",(0,i.kt)("em",{parentName:"p"},"required")," properties on any given model, and while a lot of technologies offer the validation annotations, plugins or libraries to globally enforce data validation rules, I choose to perform the validation programmatically and manually to gain more control of what would be required and what wouldn't in a TDD fashion."),(0,i.kt)("p",null,"The issue with some of the current implementations on structural and logical validations on data models is that it can be very easily changed under the radar without any unit tests firing any alarms. Check this example for instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public Student\n{\n    [Required]\n    public string Name {get; set;}\n}\n")),(0,i.kt)("p",null,"The above example can be very enticing at a glance from an engineering standpoint. All you have to do is decorate your model attribute with a magical annotation and then all of the sudden your data is being validated."),(0,i.kt)("p",null,"The problem here is that this pattern combines two different responsibilities or more together all in the same model. Models are supposed to be just a representation of objects in reality - nothing more and nothing less. Some engineers call them anemic models which focuses the responsibility of every single model to only represent the attributes of the real world object it's trying to simulate without any additional details."),(0,i.kt)("p",null,"But the annotated models now try to inject business logic into their very definitions. This business logic may or may not be needed across all services, brokers or exposing components that uses them."),(0,i.kt)("p",null,"Structural validations on models may seem like extra work that can be avoided with magical decorations. But in the case of trying to diverge slightly from these validations into a more customized validations, now you will see a new anti-pattern emerge like custom annotations that may or may not be detectable through unit tests."),(0,i.kt)("p",null,"Let's talk about how to test a structural validation routine:"),(0,i.kt)("h5",{id:"213120-testing-structural-validations"},"2.1.3.1.2.0 Testing Structural Validations"),(0,i.kt)("p",null,"Because I truly believe in the importance of TDD, I am going to start showing the implementation of structural validations by writing a failing test for it first."),(0,i.kt)("p",null,"Let's assume we have a student model, with the following details:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Student\n{\n    public Guid Id {get; set;}\n}\n")),(0,i.kt)("p",null,"We want to validate that the student Id is not a structurally invalid Id - such as an empty ",(0,i.kt)("inlineCode",{parentName:"p"},"Guid")," - therefore we would write a unit test in the following fashion:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[Fact]\npublic async void ShouldThrowValidationExceptionOnRegisterWhenIdIsInvalidAndLogItAsync()\n{\n    // given\n    Student randomStudent = CreateRandomStudent();\n    Student inputStudent = randomStudent;\n    inputStudent.Id = Guid.Empty;\n\n    var invalidStudentException = new InvalidStudentException();\n\n    invalidStudentException.AddData(\n        key: nameof(Student.Id),\n        value: "Id is required"\n    );\n\n    var expectedStudentValidationException =\n        new StudentValidationException(invalidStudentException);\n\n    // when\n    ValueTask<Student> registerStudentTask =\n        this.studentService.RegisterStudentAsync(inputStudent);\n\n    StudentValidationException actualStudentValidationException =\n        await Assert.ThrowsAsync<StudentValidationException>(\n            registerStudentTask.AsTask);\n\n    // then\n    actualStudentValidationException.Should().BeEquivalentTo(\n        expectedStudentValidationException);\n\n    this.loggingBrokerMock.Verify(broker =>\n        broker.LogError(It.Is(SameExceptionAs(\n            expectedStudentValidationException))),\n                Times.Once);\n\n    this.storageBrokerMock.Verify(broker =>\n        broker.InsertStudentAsync(It.IsAny<Student>()),\n            Times.Never);\n\n    this.dateTimeBrokerMock.VerifyNoOtherCalls();\n    this.loggingBrokerMock.VerifyNoOtherCalls();\n    this.storageBrokerMock.VerifyNoOtherCalls();\n}\n')),(0,i.kt)("p",null,"In the above test, we created a random student object then assigned the an invalid Id value of ",(0,i.kt)("inlineCode",{parentName:"p"},"Guid.Empty")," to the student ",(0,i.kt)("inlineCode",{parentName:"p"},"Id"),"."),(0,i.kt)("p",null,"When the structural validation logic in our foundation service examines the ",(0,i.kt)("inlineCode",{parentName:"p"},"Id")," property, it should throw an exception property describing the issue of validation in our student model. in this case we throw ",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidStudentException"),"."),(0,i.kt)("p",null,"The exception is required to briefly describe the whats, wheres and whys of the validation operation. in our case here the what would be the validation issue occurring, the where would be the Student service and the why would be the property value."),(0,i.kt)("p",null,"Here's how an ",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidStudentException")," would look like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public class InvalidStudentException : Xeption\n{\n    public InvalidStudentException()\n        :base ("Student is invalid. Please fix the errors and try again.")\n    { }\n}\n')),(0,i.kt)("p",null,"The above unit test however, requires our ",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidStudentException")," to be wrapped up in a more generic system-level exception, which is ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentValidationException")," - these exceptions is what I call outer-exceptions, they encapsulate all the different situations of validations regardless of their category and communicates the error to upstream services or controllers so they can map that to the proper error code to the consumer of these services."),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentValidationException")," would be implemented as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public class StudentValidationException : Exception\n{\n    public StudentValidationException(Exception innerException)\n        : base("Student validation error occurred, please check your input and then try again.", innerException) { }\n}\n')),(0,i.kt)("p",null,"The message in the outer-validation above indicates that the issue is in the input, and therefore it requires the input submitter to try again as there are no actions required from the system side to be adjusted."),(0,i.kt)("h5",{id:"213121-implementing-structural-validations"},"2.1.3.1.2.1 Implementing Structural Validations"),(0,i.kt)("p",null,"Now, let's look at the other side of the validation process, which is the implementation.\nStructural validations always come before each and every other type of validations. That's simply because structural validations are the cheapest from an execution and asymptotic time perspective.\nFor instance, It's much cheaper to validation an ",(0,i.kt)("inlineCode",{parentName:"p"},"Id")," is invalid structurally, than sending an API call across to get the exact same answer plus the cost of latency. This all adds up when multi-million requests per second start flowing in.\nStructural and logical validations in general live in their own partial class to run these validations, for instance, if our service is called ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService.cs")," then a new file should be created with the name ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService.Validations.cs")," to encapsulate and visually abstract away the validation rules to ensure clean data are coming in and going out.\nHere's how an Id validation would look like:"),(0,i.kt)("h6",{id:"studentservicevalidationscs"},"StudentService.Validations.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'\nprivate void ValidateStudent(Student student)\n{\n    Validate((Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)));\n}\n\nprivate static dynamic IsInvalid(Guid id) => new\n{\n    Condition = id == Guid.Empty,\n    Message = "Id is required"\n};\n\nprivate void Validate(params (dynamic Rule, string Parameter)[] validations)\n{\n    var invalidStudentException = new InvalidStudentException();\n\n    foreach((dynamic rule, string parameter) in validations)\n    {\n        if(rule.Condition)\n        {\n            invalidStudentException.UpsertData(parameter, rule.Message);\n        }\n    }\n\n    invalidStudentException.ThrowIfContainsErrors();\n}\n')),(0,i.kt)("p",null,"We have implemented a method to validate the entire student object, with a compilation of all the rules we need to setup to validate structurally and logically the student input object. The most important part to notice about the above code snippet is to ensure the encapsulation of any finer details further away from the main goal of a particular method."),(0,i.kt)("p",null,"That's the reason why we decided to implement a private static method ",(0,i.kt)("inlineCode",{parentName:"p"},"IsInvalid")," to abstract away the details of what determines a property of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Guid")," is invalid or not. And as we move further in the implementation, we are going to have to implement multiple overloads of the same method to validate other value types structurally and logically."),(0,i.kt)("p",null,"The purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateStudent")," method is to simply set up the rules and take an action by throwing an exception if any of these rules are violated. There's always an opportunity to aggregate the violation errors rather than throwing too early at the first sign of structural or logical validation issue to be detected."),(0,i.kt)("p",null,"Now, with the implementation above, we need to call that method to structurally and logically validate our input. Let's make that call in our ",(0,i.kt)("inlineCode",{parentName:"p"},"RegisterStudentAsync")," method as follows:"),(0,i.kt)("h6",{id:"studentservicecs"},"StudentService.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public ValueTask<Student> RegisterStudentAsync(Student student) =>\nTryCatch(async () =>\n{\n    ValidateStudent(student);\n\n    return await this.storageBroker.InsertStudentAsync(student);\n});\n")),(0,i.kt)("p",null,"At a glance, you will notice that our method here doesn't necessarily handle any type of exceptions at the logic level. That's because all the exception noise is also abstracted away in a method called ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," is a concept I invented to allow engineers to focus on what matters that most based on which aspect of the service that are looking at without having to take any shortcuts with the exception handling to make the code a bit more readable."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," methods in general live in another partial class, and an entirely new file called ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService.Exceptions.cs")," - which is where all exception handling and error reporting happens as I will show you in the following example."),(0,i.kt)("p",null,"Let's take a look at what a ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," method looks like:"),(0,i.kt)("h6",{id:"studentserviceexceptionscs"},"StudentService.Exceptions.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"private delegate ValueTask<Student> ReturningStudentFunction();\n\nprivate async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)\n{\n    try\n    {\n        return await returningStudentFunction();\n    }\n    catch (InvalidStudentException invalidStudentInputException)\n    {\n        throw CreateAndLogValidationException(invalidStudentInputException);\n    }\n}\n\nprivate StudentValidationException CreateAndLogValidationException(Exception exception)\n{\n    var studentValidationException = new StudentValidationException(exception);\n    this.loggingBroker.LogError(studentValidationException);\n\n    return studentValidationException;\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," exception noise-cancellation pattern beautifully takes in any function that returns a particular type as a delegate and handles any thrown exceptions off of that function or it's dependencies."),(0,i.kt)("p",null,"The main responsibility of a ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," function is to wrap up a service inner exceptions with outer exceptions to ease-up the reaction of external consumers of that service into only one of the three categories, which are Service Exceptions, Validations Exceptions and Dependency Exceptions. there are sub-types to these exceptions such as Dependency Validation Exceptions but these usually fall under the Validation Exception category as we will discuss in upcoming sections of The Standard."),(0,i.kt)("p",null,"In a ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," method, we can add as many inner and external exceptions as we want and map them into local exceptions for upstream services not to have a strong dependency on any particular libraries or external resource models, which we will talk about in detail when we move on to the Mapping responsibility of broker-neighboring (foundation) services."),(0,i.kt)("h4",{id:"21313-logical-validations"},"2.1.3.1.3 Logical Validations"),(0,i.kt)("p",null,"Logical validations are the second in order to structural validations. their main responsibility by definition is to logically validate whether a structurally valid piece of data is logically valid.\nFor instance, a date of birth for a student could be structurally valid by having a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1/1/1800")," but logically, a student that is over 200 years of age is an impossibility."),(0,i.kt)("p",null,"The most common logical validations are validations for audit fields such as ",(0,i.kt)("inlineCode",{parentName:"p"},"CreatedBy")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdatedBy")," - it's logically impossible that a new record can be inserted with two different values for the authors of that new record - simply because data can only be inserted by one person at a time."),(0,i.kt)("p",null,"Let's talk about how we can test-drive and implement logical validations:"),(0,i.kt)("h5",{id:"213130-testing-logical-validations"},"2.1.3.1.3.0 Testing Logical Validations"),(0,i.kt)("p",null,"In the common case of testing logical validations for audit fields, we want to throw a validation exception that the ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdatedBy")," value is invalid simply because it doesn't match the ",(0,i.kt)("inlineCode",{parentName:"p"},"CreatedBy")," field."),(0,i.kt)("p",null,"Let's assume our Student model looks as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Student {\n    Guid CreatedBy {get; set;}\n    Guid UpdatedBy {get; set;}\n}\n")),(0,i.kt)("p",null,"Our test to validate these values logically would be as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[Fact]\npublic async Task ShouldThrowValidationExceptionOnRegisterIfUpdatedByNotSameAsCreatedByAndLogItAsync()\n{\n    // given\n    Student randomStudent = CreateRandomStudent();\n    Student inputStudent = randomStudent;\n    inputStudent.UpdatedBy = Guid.NewGuid();\n\n    var invalidStudentException = new InvalidStudentException();\n\n    invalidStudentException.AddData(\n        key: nameof(Student.UpdatedBy),\n        value: $"Id is not the same as {nameof(Student.CreatedBy)}.");\n\n    var expectedStudentValidationException =\n        new StudentValidationException(invalidStudentException);\n\n    // when\n    ValueTask<Student> registerStudentTask =\n        this.studentService.RegisterStudentAsync(inputStudent);\n\n    StudentValidationException actualStudentValidationException =\n        await Assert.ThrowsAsync<StudentValidationException>(\n            registerStudentTask.AsTask);\n\n    // then\n    actualStudentValidationException.Should().BeEquivalentTo(\n        expectedStudentValidationException);\n\n    this.loggingBrokerMock.Verify(broker =>\n        broker.LogError(It.Is(SameExceptionAs(\n            expectedStudentValidationException))),\n                Times.Once);\n\n    this.storageBrokerMock.Verify(broker =>\n        broker.InsertStudentAsync(It.IsAny<Student>()),\n            Times.Never);\n\n    this.loggingBrokerMock.VerifyNoOtherCalls();\n    this.dateTimeBrokerMock.VerifyNoOtherCalls();\n    this.storageBrokerMock.VerifyNoOtherCalls();\n}\n')),(0,i.kt)("p",null,"In the above test, we have changed the value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdatedBy")," field to ensure it completely differs from the ",(0,i.kt)("inlineCode",{parentName:"p"},"CreatedBy")," field - now we expect an ",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidStudentException")," with the ",(0,i.kt)("inlineCode",{parentName:"p"},"CreatedBy")," to be the reason for this validation exception to occur."),(0,i.kt)("p",null,"Let's go ahead an write an implementation for this failing test."),(0,i.kt)("h5",{id:"213131-implementing-logical-validations"},"2.1.3.1.3.1 Implementing Logical Validations"),(0,i.kt)("p",null,"Just like we did in the structural validations section, we are going to add more rules to our validation ",(0,i.kt)("inlineCode",{parentName:"p"},"switch case")," as follows:"),(0,i.kt)("h6",{id:"studentservicevalidationscs-1"},"StudentService.Validations.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'private void ValidateStudent(Student student)\n{\n    Validate(\n        (Rule: IsNotSame(\n            firstId: student.UpdatedBy,\n            secondId: student.CreatedBy,\n            secondIdName: nameof(student.CreatedBy)),\n        Parameter: nameof(Student.UpdatedBy))\n    );\n}\n\nprivate static dynamic IsNotSame(\n    Guid firstId,\n    Guid secondId,\n    string secondIdName) => new\n    {\n        Condition = firstId != secondId,\n        Message = $"Id is not the same as {secondIdName}."\n    };\n\nprivate void Validate(params (dyanamic Rule, string Parameter)[] validations)\n{\n    var invalidStudentException = new Exception();\n\n    foreach((dynamic rule, string parameter) in validations)\n    {\n        if(rule.Condition)\n        {\n            invalidStudentException.UpsertData(\n                key: parameter,\n                value: rule.Message);\n        }\n    }\n}\n')),(0,i.kt)("p",null,"Everything else in both ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService.cs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService.Exceptions.cs")," continues to be exactly the same as we've done above in the structural validations."),(0,i.kt)("p",null,"Logical validations exceptions, just like any other exceptions that may occur are usually non-critical. However, it all depends on your business case to determine whether a particular logical, structural or even a dependency validation are critical or not, this is when you might need to create a special class of exceptions, something like ",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidStudentCriticalException")," then log it accordingly."),(0,i.kt)("h4",{id:"21314-external-validations"},"2.1.3.1.4 External Validations"),(0,i.kt)("p",null,"The last type of validations that are usually performed by foundation services is external validations. I define external validations as any form of validation that requires calling an external resource to validate whether a foundation service should proceed with processing incoming data or halt with an exception."),(0,i.kt)("p",null,"A good example of dependency validations is when we call a broker to retrieve a particular entity by it's id. If the entity returned is not found, or the API broker returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFound")," error - the foundation service is then required to wrap that error in a ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidationException")," and halts all following processes."),(0,i.kt)("p",null,"External validation exceptions can occur if the returned value did not match the expectation, such as an empty list returned from an API call when trying to insert a new coach of a team - if there is no team members, there can be no coach for instance. The foundation service in this case will be required to raise a local exception to explain the issue, something like ",(0,i.kt)("inlineCode",{parentName:"p"},"NoTeamMembersFoundException")," or something of that nature."),(0,i.kt)("p",null,"Let's write a failing test for an external validation example:"),(0,i.kt)("h5",{id:"213140-testing-external-validations"},"2.1.3.1.4.0 Testing External Validations"),(0,i.kt)("p",null,"Let's assume we are trying to retrieve a student with an ",(0,i.kt)("inlineCode",{parentName:"p"},"Id")," that doesn't match any records in the database. Here's how we would go about testing this scenario. First off, let's define a ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundStudentException")," model as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using Xeption;\n\npublic class NotFoundStudentException : Xeption\n{\n    public NotFoundStudentException(Guid id)\n        : base (message: $"Couldn\'t find a student with id: {id}.")\n    {}\n}\n')),(0,i.kt)("p",null,"The above model is the localization aspect of handling the issue. Now let's write a failing test as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async Task ShouldThrowValidationExceptionOnRetrieveByIdIfStudentNotFoundAndLogItAsync()\n{\n    // given\n    Guid randomStudentId = Guid.NewGuid();\n    Guid inputStudentId = randomStudentId;\n    Student noStudent = null;\n\n    var notFoundStudentException =\n        new NotFoundStudentException(inputStudentId);\n\n    var expectedStudentValidationException =\n        new StudentValidationException(notFoundStudentException);\n\n    this.storageBrokerMock.Setup(broker =>\n        broker.SelectStudentByIdAsync(inputStudentId))\n            .ReturnsAsync(noStudent);\n\n    // when\n    ValueTask<Student> retrieveStudentByIdTask =\n        this.studentService.RetrieveStudentByIdAsync(inputStudentId);\n\n    StudentValidationException actualStudentValidationException =\n        await Assert.ThrowsAsync<StudentValidationException>(\n            retrieveStudentByIdTask.AsTask);\n\n    // then\n    actualStudentValidationException.Should().BeEquivalentTo(\n        expectedStudentValidationException);\n\n    this.storageBrokerMock.Verify(broker =>\n        broker.SelectStudentByIdAsync(inputStudentId),\n            Times.Once);\n\n    this.loggingBrokerMock.Verify(broker =>\n        broker.LogError(It.Is(SameExceptionAs(\n            expectedStudentValidationException))),\n                Times.Once);\n\n    this.storageBrokerMock.VerifyNoOtherCalls();\n    this.loggingBrokerMock.VerifyNoOtherCalls();\n    this.dateTimeBrokerMock.VerifyNotOtherCalls();\n}\n")),(0,i.kt)("p",null,"The test above requires us to throw a localized exception as in ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundStudentException")," when the storage broker returns no values for the given ",(0,i.kt)("inlineCode",{parentName:"p"},"studentId")," and then wrap or categorize this up in ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentValidationException"),"."),(0,i.kt)("p",null,"We choose to wrap the localized exception in a validation exception and not in a dependency validation exception because the initiation of the error originated from our service not from the external resource. If the external resource is the source of the error we would have to categorize this as a ",(0,i.kt)("inlineCode",{parentName:"p"},"DependencyValidationException")," which we will discuss shortly."),(0,i.kt)("p",null,"Now let's get to the implementation part of this section to make our test pass."),(0,i.kt)("h5",{id:"213141-implementing-external-validations"},"2.1.3.1.4.1 Implementing External Validations"),(0,i.kt)("p",null,"In order to implement an external validation we will need to touch on all different aspects of our service. The core logic, the validation and the exception handling aspects are as follows."),(0,i.kt)("p",null,"First off, let's build a validation function that will throw a ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundStudentException")," if the passed-in parameter is null."),(0,i.kt)("h6",{id:"studentservicevalidationscs-2"},"StudentService.Validations.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"private static void VerifyStudentExists(Student maybeStudent, Guid studentId)\n{\n    if (maybeStudent is null)\n    {\n        throw new NotFoundStudentException(studentId);\n    }\n}\n")),(0,i.kt)("p",null,"This implementation will take care of detecting an issue and issuing a local exception ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundStudentException"),". Now let's jump over to the exception handling aspect of our service."),(0,i.kt)("h6",{id:"studentserviceexceptionscs-1"},"StudentService.Exceptions.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)\n{\n    try\n    {\n        return await returningStudentFunction();\n    }\n    ..\n    catch (NotFoundStudentException notFoundStudentException)\n    {\n        throw CreateAndLogValidationException(notFoundStudentException);\n    }\n}\n\nprivate StudentValidationException CreateAndLogValidationException(Exception exception)\n{\n    var studentValidationException = new StudentValidationException(exception);\n    this.loggingBroker.LogError(studentValidationException);\n\n    return studentValidationException;\n}\n")),(0,i.kt)("p",null,"The above implementation will take care of categorizing a ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundStudentException")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentValidationException"),". The last part is to put the pieces together as follows."),(0,i.kt)("h6",{id:"studentservicecs-1"},"StudentService.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public ValueTask<Student> RetrieveStudentByIdAsync(Guid studentId) =>\nTryCatch(async () =>\n{\n    ValidateStudentId(studentId);\n\n    Student maybeStudent =\n        await this.storageBroker.SelectStudentByIdAsync(studentId);\n\n    ValidateStudentExists(maybeStudent, studentId);\n\n    return maybeStudent;\n});\n")),(0,i.kt)("p",null,"The above implementation will ensure that the id is valid, but more importantly that whatever the ",(0,i.kt)("inlineCode",{parentName:"p"},"storageBroker")," returns will be checked for whether it's an object or ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". Then issue the exception."),(0,i.kt)("p",null,"There are situations where attempting to retrieve an entity then finding out that it doesn't exist is not necessarily erroneous. This is where Processing Services come in to leverage a higher-order business logic to deal with this more complex scenario."),(0,i.kt)("h4",{id:"21315-dependency-validations"},"2.1.3.1.5 Dependency Validations"),(0,i.kt)("p",null,"Dependency validation exceptions can occur because you called an external resource and it returned an error, or returned a value that warrants raising an error. For instance, an API call might return a ",(0,i.kt)("inlineCode",{parentName:"p"},"404")," code, and that's interpreted as an exception if the input was supposed to correspond to an existing object."),(0,i.kt)("p",null,"A more common example is when a particular input entity is using the same id as an existing entity in the system. In a relational database world, a duplicate key exception would be thrown. In a RESTful API scneario, programmatically applying the same concept also achieves the same goal for API validations assuming the granularity of the system being called weaken the referential integrity of the overall system data."),(0,i.kt)("p",null,"There are situations where the faulty response can be expressed in a fashion other than exceptions, but we shall touch on that topic in a more advanced chapters of this Standard."),(0,i.kt)("p",null,"Let's write a failing test to verify whether we are throwing a ",(0,i.kt)("inlineCode",{parentName:"p"},"DependencyValidationException")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," model already exists in the storage with the storage broker throwing a ",(0,i.kt)("inlineCode",{parentName:"p"},"DuplicateKeyException")," as a native result of the operation."),(0,i.kt)("h5",{id:"213150-testing-dependency-validations"},"2.1.3.1.5.0 Testing Dependency Validations"),(0,i.kt)("p",null,"Let's assume our student model uses an ",(0,i.kt)("inlineCode",{parentName:"p"},"Id")," with the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Guid")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Student\n{\n    public Guid Id {get; set;}\n    public string Name {get; set;}\n}\n")),(0,i.kt)("p",null,"our unit test to validate a ",(0,i.kt)("inlineCode",{parentName:"p"},"DependencyValidation")," exception would be thrown in a ",(0,i.kt)("inlineCode",{parentName:"p"},"DuplicateKey")," situation would be as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"[Fact]\npublic async void ShouldThrowDependencyValidationExceptionOnRegisterIfStudentAlreadyExistsAndLogItAsync()\n{\n    // given\n    Student someStudent = CreateRandomStudent();\n    string someMessage = GetRandomMessage();\n    var duplicateKeyException = new DuplicateKeyException(exceptionMessage);\n\n    var alreadyExistsStudentException =\n        new AlreadyExistsStudentException(duplicateKeyException);\n\n    var expectedStudentDependencyValidationException =\n        new StudentDependencyValidationException(alreadyExistsStudentException);\n\n    this.storageBrokerMock.Setup(broker =>\n        broker.InsertStudentAsync(It.IsAny<Student>()))\n            .ThrowsAsync(duplicateKeyException);\n\n    // when\n    ValueTask<Student> registerStudentTask =\n        this.studentService.RegisterStudentAsync(inputStudent);\n\n    StudentDependencyValidationException actualStudentDependencyValidationException =\n        await Assert.ThrowsAsync<StudentDependencyValidationException>(\n            registerStudentTask.AsTask);\n\n    // then\n    actualStudentDependencyValidationException.Should().BeEquivalentTo(\n        expectedStudentDependencyValidationException);\n\n    this.storageBrokerMock.Verify(broker =>\n        broker.InsertStudentAsync(It.IsAny<Student>()),\n            Times.Once);\n\n    this.loggingBrokerMock.Verify(broker =>\n        broker.LogError(It.Is(SameExceptionAs(\n            expectedStudentDependencyValidationException))),\n                Times.Once);\n\n    this.storageBrokerMock.VerifyNoOtherCalls();\n    this.loggingBrokerMock.VerifyNoOtherCalls();\n}\n")),(0,i.kt)("p",null,"In the above test, we validate that we wrap a native ",(0,i.kt)("inlineCode",{parentName:"p"},"DuplicateKeyException")," in a local model tailored to the specific model case which is the ",(0,i.kt)("inlineCode",{parentName:"p"},"AlreadyExistsStudentException")," in our example here. then we wrap that again with a generic category exception model which is the ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentDependencyValidationException"),"."),(0,i.kt)("p",null,"There's a couple of rules that govern the construction of dependency validations, which are as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Rule 1: If a dependency validation is handling another dependency validation from a downstream service, then the inner exception of the downstream exception should be the same for the dependency validation at the current level.")),(0,i.kt)("p",null,"In other words, if some ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService")," is throwing a ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentDependencyValidationException")," to an upstream service such as ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentProcessingService")," - then it's important that the ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentProcessingDependencyValidationException")," contain the same inner exception as the ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentDependencyValidationException"),". That's because once these exception are mapped into exposure components, such as API controller or UI components, the original validation message needs to propagate through the system and be presented to the end user no matter where it originated from."),(0,i.kt)("p",null,"Additionally, maintaining the original inner exception guarantees the ability to communicate different error messages through API endpoints. For instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"AlreadyExistsStudentException")," can be communicated as ",(0,i.kt)("inlineCode",{parentName:"p"},"Conflict")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"409")," on an API controller level - this differs from another dependency validation exception such as ",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidStudentReferenceException")," which would be communicated as ",(0,i.kt)("inlineCode",{parentName:"p"},"FailedDependency")," error or ",(0,i.kt)("inlineCode",{parentName:"p"},"424"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Rule 2: If a dependency validation exception is handling a non-dependency validation exception it should take that exception as it's inner exception and not anything else.")),(0,i.kt)("p",null,"These rules ensures that only the local validation exception is what's being propagated not it's native exception from a storage system or an API or any other external dependency."),(0,i.kt)("p",null,"Which is the case that we have here with our ",(0,i.kt)("inlineCode",{parentName:"p"},"AlreadyExistsStudentException")," and it's ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentDependencyValidationException")," - the native exception is completely hidden away from sight, and the mapping of that native exception and it's inner message is what's being communicated to the end user. This gives the engineers the power to control what's being communicated from the other end of their system instead of letting the native message (which is subject to change) propagate to the end-users."),(0,i.kt)("h5",{id:"213051-implementing-dependency-validations"},"2.1.3.0.5.1 Implementing Dependency Validations"),(0,i.kt)("p",null,"Depending on where the validation error originates from, the implementation of dependency validations may or may not contain any business logic. As we previously mentioned, if the error is originating from the external resource (which is the case here) - then all we have to do is just wrap that error in a local exception then categorize it with an external exception under dependency validation."),(0,i.kt)("p",null,"To ensure the aforementioned test passed, we are going to need few models.\nFor the ",(0,i.kt)("inlineCode",{parentName:"p"},"AlreadyExistsStudentException")," the implementation would be as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public class AlreadyExistsStudentException : Exception\n{\n    public AlreadyExistsStudentException(Exception innerException)\n        : base($"Student with the same Id already exists", innerException){ }\n}\n')),(0,i.kt)("p",null,"We also need the ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentDependencyValidationException")," which should be as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public class StudentDependencyValidationException : Exception\n{\n    public StudentDependencyValidationException(Exception innerException)\n        : base($"Student dependency validation error occurred, please try again.", innerException){ }\n}\n\n')),(0,i.kt)("p",null,"Now, let's go to the implementation side, let's start with the exception handling logic:"),(0,i.kt)("h6",{id:"studentserviceexceptionscs-2"},"StudentService.Exceptions.cs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"private delegate ValueTask<Student> ReturningStudentFunction();\n\nprivate async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)\n{\n    try\n    {\n        return await returningStudentFunction();\n    }\n    ...\n    catch (DuplicateKeyException duplicateKeyException)\n    {\n        var alreadyExistsStudentException = new AlreadyExistsStudentException(duplicateKeyException);\n        throw CreateAndLogDependencyValidationException(alreadyExistsStudentException);\n    }\n}\n\n...\n\nprivate StudentDependencyValidationException CreateAndLogDependencyValidationException(Exception exception)\n{\n    var studentDependencyValidationException = new StudentDependencyValidationException(exception);\n    this.loggingBroker.LogError(studentDependencyValidationException);\n\n    return studentDependencyValidationException;\n}\n")),(0,i.kt)("p",null,"We created the local inner exception in the catch block of our exception handling process to allow the reusability of our dependency validation exception method for other situations that require that same level of external exceptions."),(0,i.kt)("p",null,"Everything else stays the same for the referencing of the ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCatch")," method in the ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentService.cs")," file."),(0,i.kt)("h3",{id:"2132-mapping"},"2.1.3.2 Mapping"),(0,i.kt)("p",null,"The second responsibility for a foundation service is to play the role of a mapper both ways between local models and non-local models. For instance, if you are leveraging an email service that provides it's own SDKs to integrate with, and your brokers are already wrapping and exposing the APIs for that service, your foundation service is required to map the inputs and outputs of the broker methods into local models. the same situation and more commonly between native non-local exceptions such as the ones we mentioned above with the dependency validation situation, the same aspect applies to just dependency errors or service errors as we will discuss shortly."),(0,i.kt)("h4",{id:"21320-non-local-models"},"2.1.3.2.0 Non-Local Models"),(0,i.kt)("p",null,"Its very common for modern applications to require integration at some point with external services. these services can be local to the overall architecture or distributed system where the application lives, or it can be a 3rd party provider such as some of the popular email services for instance.\nExternal services providers invest a lot of effort in developing fluent APIs, SDKs and libraries in every common programming language to make it easy for the engineers to integrate their applications with that 3rd party service. For instance, let's assume a third party email service provider is offering the following API through their SDKs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public interface IEmailServiceProvider\n{\n    ValueTask<EmailMessage> SendEmailAsync(EmailMessage message);\n}\n")),(0,i.kt)("p",null,"Let's consider the model ",(0,i.kt)("inlineCode",{parentName:"p"},"EmailMessage")," is a native model, it comes with the email service provider SDK. your brokers might offer a wrapper around this API by building a contract to abstract away the ",(0,i.kt)("em",{parentName:"p"},"functionality")," but can't do much with the native models that are passed in or returned out of these functionality. therefore our brokers interface would look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public interface IEmailBroker\n{\n    ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message);\n}\n")),(0,i.kt)("p",null,"Then the implementation would something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class EmailBroker : IEmailBroker\n{\n    public async ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message) =>\n        await this.emailServiceProvider.SendEmailAsync(message);\n}\n")),(0,i.kt)("p",null,"As we said before, the brokers here have done their part of abstraction by pushing away the actual implementation and the dependencies of the native ",(0,i.kt)("inlineCode",{parentName:"p"},"EmailServiceProvider")," away from our foundation serviecs. But that's only 50% of the job, the abstraction isn't quite fully complete yet until there are no tracks of the native ",(0,i.kt)("inlineCode",{parentName:"p"},"EmailMessage")," model. This is where the foundation services come in to do a test-driven operation of mapping between the native non-local models and your application's local models. therefore its very possible to see a mapping function in a foundation service to abstract away the native model from the rest of your business layer services."),(0,i.kt)("p",null,"Your foundation service then will be required to support a new local model, let's call it ",(0,i.kt)("inlineCode",{parentName:"p"},"Email"),". your local model's property may be identical to the external model ",(0,i.kt)("inlineCode",{parentName:"p"},"EmailMessage")," - especially on a primitive data type level. But the new model would be the one and only contract between your pure business logic layer (processing, orchestration, coordination and management services) and your hybrid logic layer like the foundation services. Here's a code snippet for this operation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Email> SendEmailMessageAsync(Email email)\n{\n    EmailMessage inputEmailMessage = MapToEmailMessage(email);\n    EmailMessage sentEmailMessage = await this.emailBroker.SendEmailMessageAsync(inputEmailMessage);\n\n    return MapToEmail(sentEmailMessage);\n}\n\n")),(0,i.kt)("p",null,"Depending on whether the returned message has a status or you would like to return the input message as a sign of a successful operation, both practices are valid in my Standard. It all depends on what makes more sense to the operation you are trying to execute. the code snippet above is an ideal scenario where your code will try to stay true to the value passed in as well as the value returned with all the necessary mapping included."),(0,i.kt)("h4",{id:"21321-exceptions-mappings"},"2.1.3.2.1 Exceptions Mappings"),(0,i.kt)("p",null,"Just like the non-local models, exceptions that are either produced by the external API like the EntityFramework models ",(0,i.kt)("inlineCode",{parentName:"p"},"DbUpdateException")," or any other has to be mapped into local exception models.\nHandling these non-local exceptions that early before entering the pure-business layer components will prevent any potential tight coupling or dependency on any external model. as it may be very common, that exceptions can be handled differently based on the type of exception and how we want to deal with it internally in the system.\nFor instance, if we are trying to handle a ",(0,i.kt)("inlineCode",{parentName:"p"},"UserNotFoundException")," being thrown from using Microsoft Graph for instance, we might not necessarily want to exit the entire procedure. we might want to continue by adding a user in some other storage for future Graph submittal processing.\nExternal APIs should not influence whether your internal operation should halt or not. and therefore handling exceptions on the Foundation layer is the guarantee that this influence is limited within the borders of our external resources handling area of our application and has no impact whatsoever on our core business processes.\nThe following illustration should draw the picture a bit clearer from that perspective:"),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/112714067-b7366a00-8e95-11eb-9bb7-a5a047640f4a.png"})),(0,i.kt)("br",null),(0,i.kt)("p",null,"Here's some common scenarios for mapping native or inner local exceptions to outer exceptions:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Exception"),(0,i.kt)("th",{parentName:"tr",align:null},"Wrap Inner Exception With"),(0,i.kt)("th",{parentName:"tr",align:null},"Wrap With"),(0,i.kt)("th",{parentName:"tr",align:null},"Log Level"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"NullStudentException"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"InvalidStudentException"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SqlException"),(0,i.kt)("td",{parentName:"tr",align:null},"FailedStudentStorageException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyException"),(0,i.kt)("td",{parentName:"tr",align:null},"Critical")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HttpResponseUrlNotFoundException"),(0,i.kt)("td",{parentName:"tr",align:null},"FailedStudentApiException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyException"),(0,i.kt)("td",{parentName:"tr",align:null},"Critical")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HttpResponseUnauthorizedException"),(0,i.kt)("td",{parentName:"tr",align:null},"FailedStudentApiException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyException"),(0,i.kt)("td",{parentName:"tr",align:null},"Critical")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"NotFoundStudentException"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HttpResponseNotFoundException"),(0,i.kt)("td",{parentName:"tr",align:null},"NotFoundStudentException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"DuplicateKeyException"),(0,i.kt)("td",{parentName:"tr",align:null},"AlreadyExistsStudentException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HttpResponseConflictException"),(0,i.kt)("td",{parentName:"tr",align:null},"AlreadyExistsStudentException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ForeignKeyConstraintConflictException"),(0,i.kt)("td",{parentName:"tr",align:null},"InvalidStudentReferenceException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"DbUpdateConcurrencyException"),(0,i.kt)("td",{parentName:"tr",align:null},"LockedStudentException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyValidationException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"DbUpdateException"),(0,i.kt)("td",{parentName:"tr",align:null},"FailedStudentStorageException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HttpResponseException"),(0,i.kt)("td",{parentName:"tr",align:null},"FailedStudentApiException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentDependencyException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Exception"),(0,i.kt)("td",{parentName:"tr",align:null},"FailedStudentServiceException"),(0,i.kt)("td",{parentName:"tr",align:null},"StudentServiceException"),(0,i.kt)("td",{parentName:"tr",align:null},"Error")))),(0,i.kt)("p",null,"[*][Standardizing Validations & Exceptions]","(",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=Wtpxb7yPQP0"},"https://www.youtube.com/watch?v=Wtpxb7yPQP0"),")"),(0,i.kt)("p",null,"[*][Test-Driving Non-Circuit-Breaking Validations]","(",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=guJPrIQ0kJk"},"https://www.youtube.com/watch?v=guJPrIQ0kJk"),")"))}p.isMDXComponent=!0}}]);