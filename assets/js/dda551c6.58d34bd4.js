"use strict";(self.webpackChunkthe_standard=self.webpackChunkthe_standard||[]).push([[5336],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),m=a,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?o.createElement(h,s(s({ref:t},c),{},{components:n})):o.createElement(h,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var p=2;p<i;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2487:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const i={},s="3.2.1 Web Applications",r={unversionedId:"Exposers/3.2 User Interfaces/3.2.1 Web Applications/3.2.1 Web Applications",id:"Exposers/3.2 User Interfaces/3.2.1 Web Applications/3.2.1 Web Applications",title:"3.2.1 Web Applications",description:"3.2.1.0 Introduction",source:"@site/docs/3. Exposers/3.2 User Interfaces/3.2.1 Web Applications/3.2.1 Web Applications.md",sourceDirName:"3. Exposers/3.2 User Interfaces/3.2.1 Web Applications",slug:"/Exposers/3.2 User Interfaces/3.2.1 Web Applications/",permalink:"/The-Standard/docs/Exposers/3.2 User Interfaces/3.2.1 Web Applications/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/3. Exposers/3.2 User Interfaces/3.2.1 Web Applications/3.2.1 Web Applications.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"3.2 User Interfaces",permalink:"/The-Standard/docs/Exposers/3.2 User Interfaces/"},next:{title:"The Standard (v 2.0.1)",permalink:"/The-Standard/docs/intro"}},l={},p=[{value:"3.2.1.0 Introduction",id:"3210-introduction",level:2},{value:"3.2.1.1 On the Map",id:"3211-on-the-map",level:2},{value:"3.2.1.2 Charactristics",id:"3212-charactristics",level:2},{value:"3.2.1.2.0 Anatomy",id:"32120-anatomy",level:3},{value:"3.2.1.2.0.0 Base Component",id:"321200-base-component",level:4},{value:"3.2.1.2.0.0.0 Implementation",id:"3212000-implementation",level:5},{value:"3.2.1.2.0.0.1 Utilization",id:"3212001-utilization",level:5},{value:"3.2.1.2.0.0.2 Restrictions",id:"3212002-restrictions",level:5},{value:"3.2.1.2.0.1 Core Component",id:"321201-core-component",level:4},{value:"3.2.1.2.0.1.0 Implementation &amp; Tests",id:"3212010-implementation--tests",level:5},{value:"3.2.1.2.0.1.1 Restrictions",id:"3212011-restrictions",level:5},{value:"3.2.1.2.0.2 Pages",id:"321202-pages",level:4},{value:"3.2.1.2.0.3 Unobtrusiveness",id:"321203-unobtrusiveness",level:4},{value:"3.2.1.2.0.4 Organization",id:"321204-organization",level:4}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"321-web-applications"},"3.2.1 Web Applications"),(0,a.kt)("h2",{id:"3210-introduction"},"3.2.1.0 Introduction"),(0,a.kt)("p",null,"Web applications are the most common type of exposer components today. They are much more easier to use than any other known exposer UI component in the software industry. But more importantly, web applications have much more divrse set of technologies than mobile applications. The web software market is also much easier for engineer to publish to and update than mobile applications which makes it quite attractive for newer engineers in general."),(0,a.kt)("p",null,"In this chapter, we will be using Blazor technology to demonstrate implementing The Standard principles for web applications. But as I previously mentioned, The Standard is technology-agnostic. Which means it can be applied to any web technology without any issues."),(0,a.kt)("h2",{id:"3211-on-the-map"},"3.2.1.1 On the Map"),(0,a.kt)("p",null,"Web applications usually set at the other end of any system. They are the terminals that humans use to interact with the system. Let's take a look at where they are located on the map:"),(0,a.kt)("br",null),(0,a.kt)("div",null,(0,a.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/147833507-03db8680-8cf3-4353-9531-844b8d057ecb.png"})),(0,a.kt)("br",null),(0,a.kt)("p",null,"As shown above, web applications are somewhat similar to core APIs, except that they have a different group of components in terms of visualization such as Pages, Components and Bases. There's an intersection between two main flows in every web application. The presentation flow and the data/business flow. Depending on where a web application lives in terms of high-level architecture it's location determines whether it's backend (BFF or Backend of Frontend) is a business flow or just data flow. Let's discuss these details in the characteristics section in this chapter."),(0,a.kt)("h2",{id:"3212-charactristics"},"3.2.1.2 Charactristics"),(0,a.kt)("p",null,"Web applications are usually 6 basic components. Brokers, Services, View Services, Bases, Components and Pages. Since we've already discussed the data flow components in the Services portion of The Standard. In this section, we will be discussing the UI aspect (Bases, Components and Pages) with a slight detail about view services."),(0,a.kt)("p",null,"Let's discuss these charactristic here."),(0,a.kt)("h3",{id:"32120-anatomy"},"3.2.1.2.0 Anatomy"),(0,a.kt)("p",null,"UI components consist of base, components and pages. They all play the role of separating the responsibility of integration, rendering and routing users to a particular UI functionality."),(0,a.kt)("p",null,"Let's talk about these types in detail."),(0,a.kt)("h4",{id:"321200-base-component"},"3.2.1.2.0.0 Base Component"),(0,a.kt)("p",null,"Base components are just like brokers, they are wrappers around native or external UI components. Their main responsbility is to abstract away any hard dependency on non-local UI capability. For instance, let's say we want to offer the capability to create text boxes for data insertion/capture. The native ",(0,a.kt)("inlineCode",{parentName:"p"},"<input>")," tag could offer this capability. But exposing or leveraging this tag in our core UI components is dangerous. Because it creates a hard dependency on non-abstract UI components. If we decide at any point in time to use some 3rd party UI component, we would need to change these native ",(0,a.kt)("inlineCode",{parentName:"p"},"<input>")," tags across all the components that use them. That's not an optimum strategy."),(0,a.kt)("p",null,"Let's take a look at a visualization for base component functionality:"),(0,a.kt)("br",null),(0,a.kt)("div",null,(0,a.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/147835358-efab4f2a-8fc5-4e0b-bb83-326ef1292d01.png"})),(0,a.kt)("br",null),(0,a.kt)("p",null,"As seen the above example, base components will wrap an external or native UI component then expose APIs to allow the interaction with that component seamlessly and programmatically. There are occasions where these APIs will represent parameters, functions or delegates to interact with the component based on the business flow."),(0,a.kt)("h5",{id:"3212000-implementation"},"3.2.1.2.0.0.0 Implementation"),(0,a.kt)("p",null,"Let's take a look at a simple Base component for solving this problem:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},"<input @bind-value=Value />\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public partial class TextBoxBase : ComponentBase\n{\n    [Parameter]\n    public string Value {get; set;}\n\n    public void SetValue(string value) =>\n        this.Value = value;\n}\n")),(0,a.kt)("p",null,"In the code above, we wrapped the ",(0,a.kt)("inlineCode",{parentName:"p"},"<input>")," tag with our own base component ",(0,a.kt)("inlineCode",{parentName:"p"},"TextBoxBase")," and we offered an input parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"Value")," to be passed into that component so it can pass it down to the native UI element. Additionally, we also provided a public function ",(0,a.kt)("inlineCode",{parentName:"p"},"SetValue")," to allow for programmatically mimicking the users behavior to test drive the consuming component of this base element."),(0,a.kt)("h5",{id:"3212001-utilization"},"3.2.1.2.0.0.1 Utilization"),(0,a.kt)("p",null,"Now, when we try to leverage this base component at the core components level we can simply call it as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},"<TextBoxBase @ref=MyTextBox />\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," aspect will allow the backend code to interact with the base component programmatically behind the scenes to call any existing functionality."),(0,a.kt)("h5",{id:"3212002-restrictions"},"3.2.1.2.0.0.2 Restrictions"),(0,a.kt)("p",null,"Base components can only be used by Core components or just components for short. They may not be used by pages and they may not be used by other Base components. But more importantly, it's preferred that base components would only wrap around one and only one non-local component."),(0,a.kt)("p",null,"And just like Brokers, Base Components do not have any logic in them. They don't handle exceptions, do any calculations or any form of sequential, iterative or selective business logic operations. These operations are either data-based where they belong to view services and downstream APIs or UI-based where they belong to Core Components."),(0,a.kt)("p",null,"Base components also don't handle exceptions, they don't throw their own exceptions and they don't perform any type of validations."),(0,a.kt)("h4",{id:"321201-core-component"},"3.2.1.2.0.1 Core Component"),(0,a.kt)("p",null,"Core components are just like services in the data flow. They are test-driven but they are also restricted with one and only one dependency at all times. Core components leverage Base components to perform a business-specific flow. They are less generic than Base components because they orchestrate and communicate with the data flow."),(0,a.kt)("p",null,"Here's a visualization of core components architecture:"),(0,a.kt)("br",null),(0,a.kt)("div",null,(0,a.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/147836385-9e2bd7af-0199-4e7d-b50d-653e626ad0d8.png"})),(0,a.kt)("br",null),(0,a.kt)("p",null,"Core components in a way are orchestrators of UI and Data components. They will leverage one or many Base components to construct a business specific flow such as a student registration form then send the signal to view services to persist that data and return responses or report errors."),(0,a.kt)("h5",{id:"3212010-implementation--tests"},"3.2.1.2.0.1.0 Implementation & Tests"),(0,a.kt)("p",null,"Let's take a look at the implementation of a core component."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public partial class StudentRegistrationComponent : ComponentBase\n{\n    [Inject]\n    public IStudentViewService StudentViewService {get; set;}\n\n    public StudentRegistrationComponentState State {get; set;}\n    public StudentView StudentView {get; set;}\n    public TextBoxBase StudentNameTextBox {get; set;}\n    public ButtonBase SubmitButton {get; set;}\n    public LabelBase StatusLabel {get; set;}\n\n    public void OnIntialized() =>\n        this.State == StudentRegisterationComponentState.Content;\n\n    public async Task SubmitStudentAsync()\n    {\n        try\n        {\n            this.StudentViewService.AddStudentViewAsync(this.StudentView);\n        }\n        catch (Exception exception)\n        {\n            this.State = StudentRegisterationComponentState.Error;\n        }\n    }\n}\n")),(0,a.kt)("p",null,"The above code shows thee different types of properties within any given component, The dependency view service which maps raw API models/data into consumable UI models. And the ",(0,a.kt)("inlineCode",{parentName:"p"},"State")," which determines whether a component should be ",(0,a.kt)("inlineCode",{parentName:"p"},"Loading"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Content")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Error"),". The data view model to bind incoming input to one unified model ",(0,a.kt)("inlineCode",{parentName:"p"},"StudentView"),". And the last three are Base level components which are used to construct the form of registration."),(0,a.kt)("p",null,"Let's take a look at the markup side of the core component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<Condition Evaluation=IsLoading>\n    <Match>\n        <LabelBase @ref=StatusLabel Value="Loading ..." />\n    </Match>\n</Condition>\n\n<Condition Evaluation=IsContent>\n    <Match>\n        <TextBoxBase @ref=StudentNameTextBox @bind-value=StudentView.Name />\n        <ButtonBase @ref=SubmitButton Label="Submit" OnClick=SubmitStudentAsync />\n    </Match>\n</Condition>\n\n<Condition Evaluation=IsError>\n    <Match>\n        <LabelBase @ref=StatusLabel Value="Error Occurred" />\n    </Match>\n</Condition>\n')),(0,a.kt)("p",null,"We linked the references of the student registeration component properties to UI components to ensure the rendering of these components have actually occurred and the submission of data has been executed."),(0,a.kt)("p",null,"Let's take a look at a couple of tests to verify these states. a component has already loaded state. And post submission states."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[Fact]\npublic void ShouldRenderComponent()\n{\n    // given\n    StudentRegisterationComponentState expectedComponentState =\n        StudentRegisterationComponentState.Content;\n\n    // when\n    this.renderedStudentRegistrationComponent =\n        RenderComponent<StudentRegistrationComponent>();\n\n    // then\n    this.renderedStudentRegistrationComponent.Instance.StudentView\n        .Should().NotBeNull();\n\n    this.renderedStudentRegistrationComponent.Instance.State\n        .Should().Be(expectedComponentState);\n\n    this.renderedStudentRegistrationComponent.Instance.StudentNameTextBox\n        .Should().NotBeNull();\n\n    this.renderedStudentRegisterationComponent.Instance.SubmitButton\n        .Should().NotBeNull();\n\n    this.renderedStudentRegistrationComponent.Instance.StatusLabel.Value\n        .Should().BeNull();\n\n    this.studentViewServiceMock.VerifyNoOtherCalls();\n}\n")),(0,a.kt)("p",null,"The test above will verify that all the components are assigned a reference property and no external dependency calls have been made. it validates that the code in the ",(0,a.kt)("inlineCode",{parentName:"p"},"OnIntialized")," function on the component level is validated and performing as expected."),(0,a.kt)("p",null,"Now, let's take a look at the submittal code validations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[Fact]\npublic void ShouldSubmitStudentAsync()\n{\n    // given\n    StudentRegisterationComponentState expectedComponentState =\n        StudentRegisterationComponentState.Content;\n\n    var inputStudentView = new StudentView\n    {\n        Name = "Hassan Habib"\n    };\n\n    StudentView expectedStudentView = inputStudentView;\n\n    // when\n    this.renderedStudentRegistrationComponent =\n        RenderComponent<StudentRegistrationComponent>();\n\n    this.renderedStudentRegistrationComponent.Instance.StudentName\n        .SetValue(inputStudentView.Name);\n\n    this.renderedStudentRegistrationComponent.Instance.SubmitButton.Click();\n\n    // then\n    this.renderedStudentRegistrationComponent.Instance.StudentView\n        .Should().NotBeNull();\n\n    this.renderedStudentRegisterationComponent.Instance.StudentView\n        .Should().BeEquivalentTo(expectedStudentView);\n\n    this.renderedStudentRegistrationComponent.Instance.State\n        .Should().Be(expectedComponentState);\n\n    this.renderedStudentRegistrationComponent.Instance.StudentNameTextBox\n        .Should().NotBeNull();\n\n    this.renderedStudentRegistrationComponent.Instance.StudentNameTextBox.Value\n        .Should().BeEquivalentTo(studentView.Name);\n\n    this.renderedStudentRegisterationComponent.Instance.SubmitButton\n        .Should().NotBeNull();\n\n    this.renderedStudentRegistrationComponent.Instance.StatusLabel.Value\n        .Should().BeNull();\n\n    this.studentViewServiceMock.Verify(service =>\n        service.AddStudentAsync(inputStudentView),\n            Times.Once);\n\n    this.studentViewServiceMock.VerifyNoOtherCalls();\n}\n')),(0,a.kt)("p",null,"The test above validates that on submittal, the student model is populated with the data set programmatically through base component instance, but also verifies all these components are actually rendered on the screen before end-users by validating each base component has an assigned instance on runtime or render-time."),(0,a.kt)("h5",{id:"3212011-restrictions"},"3.2.1.2.0.1.1 Restrictions"),(0,a.kt)("p",null,"Core components have similar restrictions to Base components in a way they cannot call each other at that level. There's a level of Orchestration Core Components that can combine multiple components to exchange messages but they don't render anything on their own the same way Orchestration services delegate all the work to their dependencies."),(0,a.kt)("p",null,"But Core components also are not allowed to call more then one and only one view service. And in that, they stay true to the view model at all times. One views service corresponds to one core component which renders one and only one view model."),(0,a.kt)("p",null,"View services may do their own orchestration-level work as well, in an extremely complex flow but it's highly recommend to keep things at a flat level. These very same view services perform nothing but mapping and adding audit fields in addition to basic structural validations."),(0,a.kt)("h4",{id:"321202-pages"},"3.2.1.2.0.2 Pages"),(0,a.kt)("p",null,"In every web application, pages are a very fundamental mandatory container component that needs to exist so end-users could navigate to them. Pages mainly hold a route, communicate a paramter from that route and combine core-level components to represents a business value."),(0,a.kt)("p",null,"A good example for pages are dashboards. Dashboard pages are a container of multiple components like tiles, notifications, headers and side bars with references to other pages. Pages don't hold any business logic in and of themselves, but they delegate all route-related operations to their child components."),(0,a.kt)("p",null,"Let's take a look at a simple page implementation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},"@page '/registration'\n\n<HeaderComponent />\n<StudentRegisterationComponent />\n<FooterComponent />\n")),(0,a.kt)("p",null,"Pages are much simpler than core or base components. They don't require unit testing, and they don't necessarily need a backend code. They just purely reference their components without reference (unless needed) and they help serve that content when a route is navigated to."),(0,a.kt)("h4",{id:"321203-unobtrusiveness"},"3.2.1.2.0.3 Unobtrusiveness"),(0,a.kt)("p",null,"For all UI components, it's a violation to include code from multiple technologies/languages in the same page. For instance, a CSS style code, C# code and HTML markup cannot all exist at the same file. They need to separated in their own files."),(0,a.kt)("p",null,"The unobtrusiveness rule helps prevent cognitive pollution for engineers building UI components, but also makes the system much easier to maintain. That's why every component can nest it's files beneath it if the IDE/Environment used for development allows for partial implementations as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"StudentRegisterationComponent.razor",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"StudentRegisterationComponent.razor.cs"),(0,a.kt)("li",{parentName:"ul"},"StudentRegisterationComponent.razor.css")))),(0,a.kt)("p",null,"The node file here ",(0,a.kt)("inlineCode",{parentName:"p"},".razor")," file has all the markup needed to kick off the initialization of the component. While both nested files are supporting files for simple UI logic code and styling. With this level of organization (especially in Blazor) doesn't require any referencing for these nested/support files. This may not be the case for other technologies so I urge engineers to do their very best to fit that model/Standard."),(0,a.kt)("h4",{id:"321204-organization"},"3.2.1.2.0.4 Organization"),(0,a.kt)("p",null,"All UI components are listed under a Views folder in the solution. let's take a look:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Views",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Bases"),(0,a.kt)("li",{parentName:"ul"},"Components"),(0,a.kt)("li",{parentName:"ul"},"Pages")))),(0,a.kt)("p",null,"This tri-nature conforming organization should make it easier to shift reusable components and make it also easier to find these components based on their categories. I will leave it up to the preference of the engieneers to determine whether to break down these components further by folders/namespaces or leave them all at the same level given the nesting is in place."))}d.isMDXComponent=!0}}]);