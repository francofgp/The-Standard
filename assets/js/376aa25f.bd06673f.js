"use strict";(self.webpackChunkthe_standard=self.webpackChunkthe_standard||[]).push([[2767],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>p});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(r),p=i,g=h["".concat(l,".").concat(p)]||h[p]||d[p]||a;return r?n.createElement(g,o(o({ref:t},u),{},{components:r})):n.createElement(g,o({ref:t},u))}));function p(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},9291:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(7462),i=(r(7294),r(3905));const a={},o="2 Services",s={unversionedId:"Services/Services",id:"Services/Services",title:"2 Services",description:"2.0 Introduction",source:"@site/docs/2. Services/2. Services.md",sourceDirName:"2. Services",slug:"/Services/",permalink:"/The-Standard/docs/Services/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/2. Services/2. Services.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"1 Brokers",permalink:"/The-Standard/docs/Brokers/"},next:{title:"2.1 Foundation Services (Broker-Neighboring)",permalink:"/The-Standard/docs/Services/2.1 Foundations/"}},l={},c=[{value:"2.0 Introduction",id:"20-introduction",level:2},{value:"2.0.0 Services Operations",id:"200-services-operations",level:3},{value:"2.0.0.0 Validations",id:"2000-validations",level:4},{value:"2.0.0.1 Processing",id:"2001-processing",level:4},{value:"2.0.0.2 Integration",id:"2002-integration",level:4},{value:"2.0.1 Services Types",id:"201-services-types",level:3},{value:"2.0.1.0 Validators",id:"2010-validators",level:4},{value:"2.0.1.1 Orchestrators",id:"2011-orchestrators",level:4},{value:"2.0.1.2 Aggregators",id:"2012-aggregators",level:4},{value:"2.0.2 Overall Rules",id:"202-overall-rules",level:3},{value:"2.0.2.0 Do or Delegate",id:"2020-do-or-delegate",level:4},{value:"2.0.2.1 Two-Three (Florance Pattern)",id:"2021-two-three-florance-pattern",level:4},{value:"This pattern violates Florance Pattern",id:"this-pattern-violates-florance-pattern",level:6},{value:"This pattern follows the symmetry of the Pattern",id:"this-pattern-follows-the-symmetry-of-the-pattern",level:6},{value:"2.0.2.2 Single Exposure Point",id:"2022-single-exposure-point",level:4},{value:"2.0.2.3 Same or Primitives I/O Model",id:"2023-same-or-primitives-io-model",level:4},{value:"2.0.2.4 Every Service for Itself",id:"2024-every-service-for-itself",level:4},{value:"Student",id:"student",level:6},{value:"LibraryCard",id:"librarycard",level:6}],u={toc:c};function d(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2-services"},"2 Services"),(0,i.kt)("h2",{id:"20-introduction"},"2.0 Introduction"),(0,i.kt)("p",null,"Services in general are the containers of all the business logic in any given software - they are the core component of any system and the main component that makes one system different from another."),(0,i.kt)("p",null,"Our main goal with services is that to keep them completely agnostic from specific technologies or external dependencies."),(0,i.kt)("p",null,"Any business layer is more compliant with The Standard if it can be plugged into any other dependencies and exposure technologies with the least amount of integration efforts possible."),(0,i.kt)("h3",{id:"200-services-operations"},"2.0.0 Services Operations"),(0,i.kt)("p",null,"When we say business logic, we mainly refer to three main categories of operations, which are validation, processing and integration."),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/100530065-4494d680-31a2-11eb-8393-32b21ab99a3d.png"})),(0,i.kt)("br",null),(0,i.kt)("p",null,"Let's talk about these categories."),(0,i.kt)("h4",{id:"2000-validations"},"2.0.0.0 Validations"),(0,i.kt)("p",null,"Validations focus on ensuring that the incoming or outgoing data match a particular set of rules, which can be structural, logical or external validations, in that exact order of priority. We will go in details about this in the upcoming sections."),(0,i.kt)("h4",{id:"2001-processing"},"2.0.0.1 Processing"),(0,i.kt)("p",null,"Processing mainly focuses on the flow-control, mapping and computation to satisfy a business need - the processing operations specifically is what distinguishes one service from another, and in general one software from another."),(0,i.kt)("h4",{id:"2002-integration"},"2.0.0.2 Integration"),(0,i.kt)("p",null,"Finally, the integration process is mainly focused on retrieving or pushing data from or to any integrated system dependencies."),(0,i.kt)("p",null,"Every one of these aspects will be discussed in details in the upcoming chapter, but the main thing that should be understood about services is that they should be built with the intent to be pluggable and configurable so they are easily integrated with any technology from a dependency standpoint and also be easily plugged into any exposure functionality from an API perspective."),(0,i.kt)("h3",{id:"201-services-types"},"2.0.1 Services Types"),(0,i.kt)("p",null,"But services have several types based on where they stand in any given architecture, they fall under three main categories, which are: validators, orchestrators and aggregators."),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/100529444-b23e0400-319c-11eb-816a-59c73154542b.png"})),(0,i.kt)("br",null),(0,i.kt)("h4",{id:"2010-validators"},"2.0.1.0 Validators"),(0,i.kt)("p",null,"Validator services are mainly the broker-neighboring services or foundation services."),(0,i.kt)("p",null,"These services' main responsibility is to add a validation layer on top of the existing primitive operations such as the CRUD operations to ensure incoming and outgoing data is validated structurally, logically and externally before sending the data in or out of the system."),(0,i.kt)("h4",{id:"2011-orchestrators"},"2.0.1.1 Orchestrators"),(0,i.kt)("p",null,"Orchestrator services are the core of the business logic layer, they can be processors, orchestrators, coordinators or management services depending on the type of their dependencies."),(0,i.kt)("p",null,"Orchestrator services mainly focuses on combining multiple primitive operations, or multiple high-order business logic operations to achieve an even higher goal."),(0,i.kt)("p",null,"Orchestrators services are the decision makers within any architecture, they are the owners of the flow-control in any system and they are the main component that makes one application or software different from the other."),(0,i.kt)("p",null,"Orchestrator services are also meant to be built and live longer than any other type of services in the system."),(0,i.kt)("h4",{id:"2012-aggregators"},"2.0.1.2 Aggregators"),(0,i.kt)("p",null,"Aggregator services main responsibility is to tie the outcome of multiple processing, orchestration, coordination or management services to expose one single API for any given API controller, or UI component to interact with the rest of the system."),(0,i.kt)("p",null,"Aggregators are the gatekeepers of the business logic layer, they ensure the data exposure components (like API controllers) are interacting with only one point of contact to interact with the rest of the system."),(0,i.kt)("p",null,"Aggregators in general don't really care about the order in which they call the operations that is attached to them, but sometimes it becomes a necessity to execute a particular operation, such as creating a student record before assigning a library card to them."),(0,i.kt)("p",null,"We will discuss each and every type of these services in detail in the next chapters."),(0,i.kt)("h3",{id:"202-overall-rules"},"2.0.2 Overall Rules"),(0,i.kt)("p",null,"There are several rules that govern the overall architecture and design of services in any system."),(0,i.kt)("p",null,"These rules ensure the overall readability, maintainability, configurability of the system - in that particular order."),(0,i.kt)("h4",{id:"2020-do-or-delegate"},"2.0.2.0 Do or Delegate"),(0,i.kt)("p",null,"Every service should either do the work or delegate the work but not both."),(0,i.kt)("p",null,"For instance, a processing service should delegate the work of persisting data to a foundation service and not try to do that work by itself."),(0,i.kt)("h4",{id:"2021-two-three-florance-pattern"},"2.0.2.1 Two-Three (Florance Pattern)"),(0,i.kt)("p",null,"For Orchestrator services, their dependencies of services (not brokers) should be limited to 2 or 3 but not 1 and not 4 or more."),(0,i.kt)("p",null,"The dependency on one service denies the very definition of orchestration. That's because orchestration by definition is the combination between multiple different operations from different sources to achieve a higher order of business-logic."),(0,i.kt)("h6",{id:"this-pattern-violates-florance-pattern"},"This pattern violates Florance Pattern"),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/100561648-4926c100-326e-11eb-9028-96bcd3eb0b1d.png"})),(0,i.kt)("br",null),(0,i.kt)("h6",{id:"this-pattern-follows-the-symmetry-of-the-pattern"},"This pattern follows the symmetry of the Pattern"),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("img",{src:"https://user-images.githubusercontent.com/1453985/100561978-2a74fa00-326f-11eb-9d05-404eed3eaf5f.png"})),(0,i.kt)("br",null),(0,i.kt)("p",null,"The Florance pattern also ensures the balance and symmetry of the overall architecture as well."),(0,i.kt)("p",null,"For instance, you can't orchestrate between a foundation and a processing service, it causes a form of unbalance in your architecture, and an uneasy disturbance in trying to combine one unified statement with the language each service speaks based on their level and type."),(0,i.kt)("p",null,"The only type of services that is allowed to violate this rule are the aggregators, where the combination and the order of services or their calls doesn't have any real impact."),(0,i.kt)("p",null,"We will be discussing the Florance pattern a bit further in detail in the upcoming sections of The Standard."),(0,i.kt)("h4",{id:"2022-single-exposure-point"},"2.0.2.2 Single Exposure Point"),(0,i.kt)("p",null,"API controllers, UI components or any other form of data exposure from the system should have one single point of contact with the business-logic layer."),(0,i.kt)("p",null,"For instance, an API endpoint that offer endpoints for persisting and retrieving student data, should not have multiple integrations with multiple services, but rather one service that offers all of these features."),(0,i.kt)("p",null,"Sometimes, a single orchestration, coordination or management service does not offer everything related to a particular entity, in which case an aggregator service is necessary to combine all of these features into one service ready to be integrated with by an exposure technology."),(0,i.kt)("h4",{id:"2023-same-or-primitives-io-model"},"2.0.2.3 Same or Primitives I/O Model"),(0,i.kt)("p",null,"For all services, they have to maintain a single contract in terms of their return and input types, except if they were primitives."),(0,i.kt)("p",null,"For instance, a service that provides any kind of operations for an entity type ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," - should not return from any of its methods any other entity type."),(0,i.kt)("p",null,"You may return an aggregation of the same entity whether it's custom or native such as ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Student>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"AggregatedStudents")," models, or a primitive type like getting students count, or a boolean indicating whether a student exists or not but not any other non-primitive or non-aggregating contract."),(0,i.kt)("p",null,"For input parameters a similar rule applies - any service may receive an input parameter of the same contract or a virtual aggregation contract or a primitive type but not any other contract, that simply violates the rule."),(0,i.kt)("p",null,"This rule enforces the focus of any service to maintain it's responsibility on a single entity and all it's related operations."),(0,i.kt)("p",null,"Once a service returns a different contract, it simply violates it's own naming convention like a ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentOrchestrationService")," returning ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Teacher>")," - and it starts falling into the trap of being called by other services from a completely different data pipelines."),(0,i.kt)("p",null,"For primitive input parameters, if they belong to a different entity model, that is not necessarily a reference on the main entity, it begs the question to orchestrate between two processing or foundation services to maintain a unified model without break the pure-contracting rule."),(0,i.kt)("p",null,"If the combination between multiple different contracts in an orchestration service is required, then a new unified virtual model has to be the new unique contract for the orchestration service with mappings implemented underneath on the concrete level of that service to maintain compatibility and integration safety."),(0,i.kt)("h4",{id:"2024-every-service-for-itself"},"2.0.2.4 Every Service for Itself"),(0,i.kt)("p",null,"Every service is responsible for validating its inputs and outputs. You should not rely on services up or downstream to validate your data."),(0,i.kt)("p",null,"This is a defensive programming mechanism to ensure that in case of swapping implementations behind contracts, the responsibility of any given services wouldn't be affected if down or upstream services decided to pass on their validations for any reason."),(0,i.kt)("p",null,"Within any monolithic, microservice or serverless architecture-based system, every service is built with the intent that it would split off of the system at some point, and become the last point of contact before integrating with some external resource broker."),(0,i.kt)("p",null,"For instance, in the following architecture, services are mapping parts of an input ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," model into a ",(0,i.kt)("inlineCode",{parentName:"p"},"LibraryCard")," model, here's a visual of the models:"),(0,i.kt)("h6",{id:"student"},"Student"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Student\n{\n    public Guid Id {get; set;}\n    public string Name {get; set;}\n}\n")),(0,i.kt)("h6",{id:"librarycard"},"LibraryCard"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class LibraryCard\n{\n    public Guid Id {get; set;}\n    public Guid StudentId {get; set;}\n}\n")),(0,i.kt)("p",null,"Now, assume that our orchestrator service ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentOrchestrationService")," is ensuring every new student that gets registered will need to have a library card, so our logic may look as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async ValueTask<Student> RegisterStudentAsync(Student student)\n{\n    Student registeredStudent =\n        await this.studentProcessingService.RegisterStudentAsync(student);\n\n    await AssignStudentLibraryCardAsync(student);\n\n    return registeredStudent;\n}\n\nprivate async ValueTask<LibraryCard> AssignStudentLibraryCardAsync(Student student)\n{\n    LibraryCard studentLibraryCard = MapToLibraryCard(student);\n\n    return await this.libraryCardProcessingService.AddLibraryCardAsync(studentLibraryCard);\n}\n\nprivate LibraryCard MapToLibraryCard(Student student)\n{\n    return new LibraryCard\n    {\n        Id = Guid.NewGuid(),\n        StudentId = student.Id\n    };\n}\n")),(0,i.kt)("p",null,"As you can see above, a valid student id is required to ensure a successful mapping to a ",(0,i.kt)("inlineCode",{parentName:"p"},"LibraryCard")," - and since the mapping is the orchestrator's responsibility, we are required to ensure that the input student and its id is in good shape before proceeding with the orchestration process."))}d.isMDXComponent=!0}}]);